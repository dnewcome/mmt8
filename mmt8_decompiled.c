/*
 * Alesis MMT-8 Firmware v1.11 - Decompiled C Pseudocode
 * CPU: 80C31 (8051 family), 12 MHz crystal
 * Generated by Ghidra 12.0
 *
 * MEMORY MAP:
 *   CODE  0x0000-0x7FFF: 27C256 EPROM (program memory)
 *   XDATA 0x0000-0x7FFF: 61256 SRAM bank 0 (U10)
 *   XDATA 0x8000-0xFFFF: 61256 SRAM bank 1 (U9)
 *   IRAM  0x00-0x7F: Internal RAM (direct addressable)
 *   IRAM  0x80-0xFF: Internal RAM (indirect only)
 *   SFR   0x80-0xFF: Special Function Registers
 *
 * I/O PORTS (memory-mapped in XDATA via HC138 decoder):
 *   0xFF00: IO_CTRL_0 (HC574 output latch)
 *   0xFF04: IO_CTRL_1 (output latch)
 *   0xFF08: LCD_DATA (HD44780 LCD)
 *   0xFF0E: IO_INPUT_0 (button/status input)
 *   0xFF0F: IO_INPUT_1
 *   0xFF1A: IO_INPUT_2
 *
 * INTERRUPT VECTORS:
 *   0x0000: RESET
 *   0x0003: EXT_INT0 (timing tick counter)
 *   0x000B: TIMER0 (reload TH0/TL0, MIDI timing)
 *   0x0013: EXT_INT1 (unused, shares RETI)
 *   0x001B: TIMER1 (UART baud rate)
 *   0x0023: SERIAL (MIDI RX/TX, reg bank 2/3)
 */


/* ====================================================================== */
/* ISR: EXT_INT0 (timing tick counter) */
/* Function at 0x0003: EXT_INT0_isr */
/* ====================================================================== */

/* External INT0 ISR: increments tick_counter (IRAM 0x7D).
   Used as timing pulse counter for sequencer clock. */

void EXT_INT0_isr(void)

{
  tick_counter = tick_counter + '\x01';
  return;
}



/* ====================================================================== */
/* ISR: TIMER0 (reload TH0/TL0, MIDI timing) */
/* Function at 0x000B: TIMER0_isr */
/* ====================================================================== */

/* Timer 0 ISR: reloads TH0/TL0 from IRAM 0x7E/0x7F (variable tempo),
   then increments tick_counter. This is the core MIDI clock source. */

void TIMER0_isr(void)

{
  TH0 = timer0_reload_hi;
  TL0 = timer0_reload_lo;
  tick_counter = tick_counter + '\x01';
  return;
}



/* ====================================================================== */
/* ISR: EXT_INT1 (unused, shares RETI) */
/* Function at 0x0013: EXT_INT1_isr */
/* ====================================================================== */

/* External INT1 ISR: unused. Just RETI (shared with Timer0 handler). */

void EXT_INT1_isr(void)

{
  return;
}



/* ====================================================================== */
/* ISR: SERIAL (MIDI RX/TX, reg bank 2/3) */
/* Function at 0x0023: SERIAL_isr */
/* ====================================================================== */

/* UART Serial ISR: handles MIDI RX and TX.
   Uses register bank 2 (TX) and bank 3 (RX) for fast context switching.
   RX: reads SBUF into buffer via @R1 (bank3), disables ES when buffer full.
   TX: sends next byte from buffer via @R0 (bank2), sets _c_4 when done.
   P2 saved/restored via IRAM 0x5C to preserve XDATA page context. */

undefined1 SERIAL_isr(undefined1 param_1,byte param_2,byte param_3)

{
  undefined1 uVar1;
  char cVar2;
  
  RS1 = 1;
  cVar2 = RI;
  if (cVar2 != '\0') {
    RI = 0;
    RS0 = 1;
    P2 = 1;
    uVar1 = SBUF;
    *(undefined1 *)(ushort)param_3 = uVar1;
    if (param_2 == BANK3_R1) {
      ES = 0;
      P2 = saved_P2_page;
      return param_1;
    }
  }
  cVar2 = TI;
  if (cVar2 != '\0') {
    TI = 0;
    P2 = 0;
    RS0 = 0;
    if (param_2 == BANK2_R1) {
      _c_4 = 0;
      P2 = saved_P2_page;
      return param_1;
    }
    SBUF = *(undefined1 *)(ushort)param_2;
    P2 = saved_P2_page;
    return param_1;
  }
  P2 = saved_P2_page;
  return param_1;
}



/* ====================================================================== */
/* Function at 0x006D: init_sequencer_defaults */
/* ====================================================================== */

/* Initialize default sequencer parameters in XDATA pages 4 and 5.
   Page 4 (P2=4): clears 0x00-0xC9, sets tempo/time sig defaults:
     0xCF=0x62(tempo), 0xD0=0x06, 0xD1-D4=timer reload values.
   Page 5 (P2=5): clears buffers 0x00-0xC9 and 0xD8-0xE7,
     sets 0x4D5=1, 0x4D6=1, 0x4D9=4, 0x4E3=5, 0x4D8=0x60(96ppqn), 0x4DA=0x78(120bpm). */

void init_sequencer_defaults(void)

{
  byte bVar1;
  
  P2 = 4;
  uEXTMEM0000 = 6;
  uEXTMEM0001 = 0;
  bVar1 = 2;
  do {
    *(undefined1 *)(ushort)bVar1 = 0;
    bVar1 = bVar1 + 1;
  } while (bVar1 != 0xca);
  uEXTMEM00ca = 0;
  uEXTMEM00cb = 0;
  uEXTMEM00e4 = 0;
  uEXTMEM00cc = 1;
  uEXTMEM00cd = 1;
  uEXTMEM00cf = 0x62;
  uEXTMEM00d0 = 6;
  uEXTMEM00d1 = 0xff;
  uEXTMEM00d2 = 0xfe;
  uEXTMEM00d3 = 0x9e;
  uEXTMEM00d4 = 0xf8;
  copy_code_to_xdata(0x600);
  P2 = 5;
  bVar1 = 0;
  do {
    *(undefined1 *)(ushort)bVar1 = 0;
    bVar1 = bVar1 + 1;
  } while (bVar1 != 0xca);
  uEXTMEM00ca = 0;
  uEXTMEM00cb = 0;
  uEXTMEM00cc = 0;
  uEXTMEM00d7 = 0;
  bVar1 = 0xd8;
  do {
    *(undefined1 *)(ushort)bVar1 = 0;
    bVar1 = bVar1 + 1;
  } while (bVar1 != 0xe8);
  uEXTMEM04d5 = 1;
  uEXTMEM04d6 = 1;
  uEXTMEM04d7 = 0;
  uEXTMEM04d9 = 4;
  uEXTMEM04e3 = 5;
  uEXTMEM04d8 = 0x60;
  uEXTMEM04da = 0x78;
  return;
}



/* ====================================================================== */
/* Function at 0x00FB: RESET_vector */
/* ====================================================================== */

/* === MAIN INITIALIZATION AND EVENT LOOP ===
   Hardware: 80C31 @ 12MHz, 27C256 EPROM, 2x 61256 SRAM
   MIDI: 31.25 kbaud via Timer1 auto-reload (TH1=0xFF)
   Sequencer: 96 PPQN, Timer0 variable tempo, 8 tracks
   I/O: HC574 latches for keyboard/LEDs, HD44780 LCD
   Memory: P2 selects 256-byte XDATA pages (0-5 used)
     Page 0: MIDI TX buffer
     Page 1: MIDI RX buffer
     Page 2: Track event buffers (note on/off/CC queues)
     Page 3: Active note tracking
     Page 4: Sequence parameters and configuration
     Page 5: Song mode data and extended parameters */

void RESET_vector(char param_1)

{
  bool bVar1;
  undefined1 *puVar2;
  char *pcVar3;
  char *pcVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  char cVar9;
  byte bVar10;
  char cVar11;
  byte bVar12;
  byte bVar13;
  undefined1 *puVar14;
  undefined2 uVar15;
  char *pcVar16;
  byte *pbVar17;
  byte *pbVar18;
  
  do {
    SP = 0x2f;
    TMOD = 0x21;
    TCON = 0x51;
    IP = 1;
    SCON = 0x70;
    TH1 = 0xff;
    TL1 = 0xff;
    puVar2 = &BANK0_R2;
    do {
      *puVar2 = 0;
      puVar2 = puVar2 + '\x01';
      do {
        param_1 = param_1 + -1;
      } while (param_1 != '\0');
    } while (puVar2 != (undefined1 *)0x80);
    IO_LED_CONTROL = 1;
    puVar14 = (undefined1 *)0xff08;
    LCD_CMD_DATA = 0x38;
    lcd_long_delay();
    lcd_long_delay();
    lcd_long_delay();
    *puVar14 = 0x38;
    lcd_short_delay();
    *puVar14 = 6;
    lcd_short_delay();
    *puVar14 = 0xe;
    lcd_short_delay();
    *puVar14 = 1;
    lcd_long_delay();
    puVar14 = &IO_KEY_COLUMN_SEL;
    IO_KEY_COLUMN_SEL = 0xfe;
    lcd_short_delay();
    cVar11 = P1;
    if (cVar11 == -5) {
      *puVar14 = 0xfd;
      lcd_short_delay();
      cVar11 = P1;
      if (cVar11 != -1) goto LAB_CODE_0192;
      *puVar14 = 0xfb;
      lcd_short_delay();
      cVar11 = P1;
      if (cVar11 != '?') goto LAB_CODE_0192;
      *puVar14 = 0xf7;
      lcd_short_delay();
      cVar11 = P1;
      if (cVar11 != -1) goto LAB_CODE_0192;
      *puVar14 = 0xef;
      lcd_short_delay();
      cVar11 = P1;
      if (cVar11 != -1) goto LAB_CODE_0192;
      *puVar14 = 0xdf;
      lcd_short_delay();
      cVar11 = P1;
      if (cVar11 != -1) goto LAB_CODE_0192;
LAB_CODE_01b1:
      *(undefined1 *)ZEXT12(puVar2) = 0xb5;
      *(undefined1 *)ZEXT12(puVar2 + -1) = 0x27;
      init_sequencer_defaults();
      display_tempo_info();
LAB_CODE_01be:
      P2 = 4;
      uEXTMEM00e5 = 0x80;
      uEXTMEM00e6 = 0xdf;
      uEXTMEM00e7 = 0xff;
      uEXTMEM00e8 = 0;
      uEXTMEM00e9 = 0x80;
      uEXTMEM00ea = 0;
      uEXTMEM00eb = 0;
      RS1 = 1;
      RS0 = 1;
      RS0 = 0;
      RS1 = 0;
      P2 = 2;
      uEXTMEM0000 = 0;
      uEXTMEM001f = 0;
      uEXTMEM0034 = 0;
      uEXTMEM006b = 0;
      uEXTMEM00a2 = 0;
      init_param_a = 0xb;
      init_param_b = 0x26;
      tick_counter = '\0';
      _c_4 = '\0';
      _c_5 = 0;
      _c_6 = 0;
      bEXTMEM04ce = 0xff;
      _e_5 = 1;
      _f_0 = 1;
      last_button_state = 0xff;
      if (cEXTMEM04ca == 'd') {
        _f_2 = '\x01';
        init_song_playback();
        IO_STATUS_LATCH = 0xef;
      }
      else {
        load_sequence_from_storage(0);
        IO_STATUS_LATCH = 0xfb;
      }
      IO_TRANSPORT_STATE = '\0';
      IO_BEAT_DIVIDER = 1;
      IO_CLICK_ENABLE = '\x01';
      _f_1 = 1;
      lcd_print_string(0x2289);
      _c_0 = 0;
      scan_keyboard();
      _c_0 = _8_4 & 1;
      IE = 0x92;
      IE0 = 0;
      update_display_full();
LAB_CODE_025f:
      if (_f_2 == '\0') {
        display_track_mode_screen();
        uVar15 = 0x3c8;
      }
      else {
        display_song_mode_screen();
        uVar15 = 0x4b7;
      }
      display_ptr_lo = (undefined1)uVar15;
      display_ptr_hi = (undefined1)((ushort)uVar15 >> 8);
      IO_STATUS_LATCH = IO_STATUS_LATCH | 0x89;
      _d_1 = '\0';
LAB_CODE_0280:
      do {
        scan_keyboard();
        lcd_long_delay();
        lcd_long_delay();
        lcd_long_delay();
        if (IO_TRANSPORT_STATE == '\0') {
          tick_counter = '\0';
        }
        RS1 = 1;
        RS0 = 1;
        process_midi_input();
        RS0 = 0;
        RS1 = 0;
        process_midi_realtime_msgs();
        if (_f_3 != '\0') {
          _d_1 = '\0';
          _f_5 = '\0';
          if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) {
            display_ptr_lo = 0x3b;
            display_ptr_hi = 0x16;
            IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
          }
          else {
            start_recording_new_sequence();
          }
          setup_recording_state();
          _f_6 = '\0';
          track_mute_mask = 0;
          if (_c_3 == '\0') goto LAB_CODE_0fa0;
          start_track_playback();
          goto LAB_CODE_0fa0;
        }
        clear_track_event_buffers();
        if ((_8_4 == 1) || (_0_4 != '\0')) {
          if (IO_TRANSPORT_STATE == '\x01') {
            tick_counter = '\0';
          }
LAB_CODE_02e1:
          _d_1 = '\0';
          _f_5 = '\0';
          if (_f_2 != '\x01') {
            if (_6_7 == '\0') {
              if ((IO_STATUS_LATCH & 8) == 0) {
                start_recording_new_sequence();
                goto LAB_CODE_0f51;
              }
            }
            else {
              continue_recording_existing();
            }
          }
          display_ptr_lo = 0x3b;
          display_ptr_hi = 0x16;
          IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
LAB_CODE_0f51:
          do {
            while( true ) {
              _f_4 = 0;
              send_midi_timing_clock(0xfa);
              if (_c_3 == '\0') {
                if (_f_2 != '\0') {
                  cEXTMEM05cd = '\0';
                  init_song_playback();
                }
                update_display_full();
LAB_CODE_0f76:
                track_mute_mask = 0;
              }
              else {
                start_track_playback();
              }
              TF0 = 1;
              _f_6 = '\0';
              if (_c_3 != '\0') break;
LAB_CODE_0fa0:
              if ((_f_2 != '\0') && (cEXTMEM05ce == -1)) {
                _d_7 = 0;
                stop_all_playing_notes();
                _e_1 = 0;
                goto LAB_CODE_025f;
              }
              cEXTMEM04ed = cEXTMEM04ca;
              _e_1 = 0;
              if (_f_5 != '\x01') {
                update_position_display();
              }
              _c_7 = '\0';
              IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfe;
              _d_7 = 1;
              _0_4 = '\0';
              _0_5 = '\0';
              _8_4 = 0;
              cEXTMEM04ec = '0';
              IO_IDLE_COUNTER = '\0';
LAB_CODE_1076:
              while( true ) {
                cEXTMEM04ec = cEXTMEM04ec + -1;
                if (cEXTMEM04ec == '\0') {
                  cEXTMEM04ec = '0';
                  scan_keyboard();
                  check_transport_buttons();
                  check_data_transfer_state();
                  if ((_0_7 != '\0') && (cEXTMEM04cb == cEXTMEM04ca)) {
                    stop_track_playback();
                  }
                }
                RS1 = 1;
                RS0 = 1;
                process_midi_input();
                RS0 = 0;
                RS1 = 0;
                if (_0_4 != '\0') break;
                if ((_8_4 == 1) || (_0_5 != '\0')) {
LAB_CODE_10c0:
                  _d_7 = 0;
                  configure_tempo_timer();
                  stop_all_playing_notes();
                  send_midi_stop_msg();
                  _e_1 = 0;
                  send_midi_song_position();
                  if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) goto LAB_CODE_025f;
                  IO_STATUS_LATCH = IO_STATUS_LATCH | 0x81;
                  handle_auto_continue_record();
                  goto LAB_CODE_0280;
                }
                if (tick_counter == '\0') {
                  IO_IDLE_COUNTER = IO_IDLE_COUNTER + '\x01';
                  if ((((IO_IDLE_COUNTER == '\0') &&
                       (IO_TIMEOUT_COUNTER = IO_TIMEOUT_COUNTER + '\x01',
                       IO_TIMEOUT_COUNTER == '\x14')) && (IO_TRANSPORT_STATE == '\x02')) &&
                     (IO_CLICK_ENABLE != '\0')) goto LAB_CODE_10c0;
                  if (_c_3 == '\x01') {
                    process_recording_step();
                  }
                  else {
                    clear_track_event_buffers();
                  }
                }
                else {
                  tick_counter = tick_counter + -1;
                  T0 = 1;
                  IO_IDLE_COUNTER = '\0';
                  IO_TIMEOUT_COUNTER = '\0';
                  bVar1 = 0xfe < midi_clock_lo;
                  midi_clock_lo = midi_clock_lo + 1;
                  midi_clock_hi = midi_clock_hi - ((bVar1 << 7) >> 7);
                  tick_subdivider = tick_subdivider - 1;
                  bVar12 = tick_subdivider;
                  if (tick_subdivider == 0) {
                    tick_subdivider = 0x60;
LAB_CODE_1146:
                    if ((bVar12 & 3) == 0) {
                      send_midi_timing_clock(0xf8);
                    }
LAB_CODE_11e7:
                    click_countdown = click_countdown + -1;
                    if (click_countdown == '\0') {
                      if (tick_subdivider == 0x60) {
                        cEXTMEM05d5 = cEXTMEM04d8;
                      }
                      cVar11 = cEXTMEM04d6;
                      if (_c_3 != '\x01') {
                        cVar11 = cEXTMEM04d7;
                      }
                      click_countdown = cEXTMEM05d5;
                      if (cVar11 != '\0') {
                        bVar12 = T1;
                        T1 = bVar12 ^ 1;
                        bVar12 = T1;
                        T1 = bVar12 ^ 1;
                      }
                    }
                    if (_c_3 != '\0') {
                      if (_f_6 == '\0') {
                        process_recording_realtime();
                      }
                      else {
                        _f_6 = '\0';
                        process_recording_step();
                      }
                      goto LAB_CODE_122e;
                    }
LAB_CODE_122b:
                    clear_track_event_buffers();
LAB_CODE_122e:
                    current_track_idx = 0;
                    track_bit_rotate = 1;
                    pcVar3 = (char *)0x5d;
LAB_CODE_1236:
                    active_track_mask = ~track_mute_mask & bEXTMEM04ce;
                    do {
                      _d_0 = (active_track_mask & track_bit_rotate) != 0;
                      _d_1 = (track_mute_mask & track_bit_rotate) != 0;
                      pbVar18 = (byte *)CONCAT11(4,current_track_idx * '\x02' + -0x10);
                      bVar12 = *pbVar18;
                      bVar10 = bVar12 + 1;
                      *pbVar18 = bVar10;
                      pcVar16 = (char *)CONCAT11(4,current_track_idx * '\x02' + -0xf);
                      *pcVar16 = *pcVar16 - (((0xfe < bVar12) << 7) >> 7);
                      cVar11 = *(char *)CONCAT11(4,current_track_idx - 0x25) + -1;
                      pcVar4 = pcVar3 + '\x01';
                      pbVar18 = (byte *)CONCAT11(*pcVar4,*pcVar3);
                      if (*pcVar4 != '\0') {
                        bVar12 = *pbVar18 & 0x7f;
                        pbVar17 = pbVar18 + 2;
                        if ((pbVar18[1] == BANK0_R1) && (*pbVar17 == BANK0_R3)) {
                          do {
                            bVar7 = pbVar17[1];
                            bVar6 = pbVar17[2];
                            if ((-1 < (char)bVar7) && ((char)bVar6 < '\0')) {
                              if ((_d_1 == '\x01') ||
                                 (*pcVar4 = '\0', bVar12 = BANK0_R0, _f_2 == '\0'))
                              goto LAB_CODE_1371;
                              handle_song_part_change(current_track_idx);
                              pcVar3 = pcVar4 + -1;
                              BANK0_R0 = bVar12;
                              goto LAB_CODE_1236;
                            }
                            bVar8 = bVar6;
                            if ((cVar11 != -1) && (bVar8 = BANK0_R7, bVar7 == 0xfd)) {
                              bVar8 = bVar6;
                            }
                            bVar6 = pbVar17[3];
                            bVar13 = pbVar17[4];
                            pbVar17 = pbVar17 + 5;
                            if ((char)bVar7 < '\0') {
                              bVar7 = bVar7 & 0x7f;
                              if (BANK0_R2 == 0x7a) {
                                if (_c_7 != '\0') {
                                  midi_tx_end_sysex();
                                }
                                if (_d_0 == '\x01') {
                                  RS1 = 1;
                                  saved_P2_page = 0;
                                  P2 = 0;
                                  ES = 0;
                                  if (_c_4 != '\x01') {
                                    TI = 1;
                                    _c_4 = '\x01';
                                  }
                                  *(byte *)(ushort)bVar10 = BANK0_R3 | 0xc0;
                                  bVar12 = bVar10 + 1;
                                  if (bVar10 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  *(byte *)(ushort)bVar12 = bVar7;
                                  bVar10 = bVar12 + 1;
                                  if (bVar12 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  ES = 1;
                                  RS1 = 0;
                                }
                              }
                              else if (BANK0_R2 < 0x7a) {
                                if (_c_7 != '\0') {
                                  midi_tx_end_sysex();
                                }
                                if (_d_0 == '\x01') {
                                  RS1 = 1;
                                  saved_P2_page = 0;
                                  P2 = 0;
                                  ES = 0;
                                  if (_c_4 != '\x01') {
                                    TI = 1;
                                    _c_4 = '\x01';
                                  }
                                  *(byte *)(ushort)bVar10 = BANK0_R3 | 0xb0;
                                  bVar12 = bVar10 + 1;
                                  if (bVar10 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  *(byte *)(ushort)bVar12 = BANK0_R2;
                                  bVar6 = bVar12 + 1;
                                  if (bVar12 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  *(byte *)(ushort)bVar6 = bVar7;
                                  bVar10 = bVar6 + 1;
                                  if (bVar6 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  ES = 1;
                                  RS1 = 0;
                                }
                              }
                              else if (BANK0_R2 == 0x7b) {
                                if (_c_7 != '\0') {
                                  midi_tx_end_sysex();
                                }
                                if (_d_0 == '\x01') {
                                  RS1 = 1;
                                  saved_P2_page = 0;
                                  P2 = 0;
                                  ES = 0;
                                  if (_c_4 != '\x01') {
                                    TI = 1;
                                    _c_4 = '\x01';
                                  }
                                  *(byte *)(ushort)bVar10 = BANK0_R3 | 0xd0;
                                  bVar12 = bVar10 + 1;
                                  if (bVar10 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  *(byte *)(ushort)bVar12 = bVar7;
                                  bVar10 = bVar12 + 1;
                                  if (bVar12 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  ES = 1;
                                  RS1 = 0;
                                }
                              }
                              else if (BANK0_R2 == 0x7c) {
                                if (_c_7 != '\0') {
                                  midi_tx_end_sysex();
                                }
                                if (_d_0 == '\x01') {
                                  RS1 = 1;
                                  saved_P2_page = 0;
                                  P2 = 0;
                                  ES = 0;
                                  if (_c_4 != '\x01') {
                                    TI = 1;
                                    _c_4 = '\x01';
                                  }
                                  *(byte *)(ushort)bVar10 = BANK0_R3 | 0xe0;
                                  bVar12 = bVar10 + 1;
                                  if (bVar10 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  *(undefined1 *)(ushort)bVar12 = BANK0_R4;
                                  bVar7 = bVar12 + 1;
                                  if (bVar12 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  *(char *)(ushort)bVar7 = BANK0_R5;
                                  bVar10 = bVar7 + 1;
                                  if (bVar7 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  ES = 1;
                                  RS1 = 0;
                                }
                              }
                              else if (BANK0_R2 == 0x7d) {
                                if (_d_0 == '\x01') {
                                  RS1 = 1;
                                  saved_P2_page = 0;
                                  P2 = 0;
                                  ES = 0;
                                  if (_c_4 != '\x01') {
                                    TI = 1;
                                    _c_4 = '\x01';
                                  }
                                  if (_c_7 != '\x01') {
                                    _c_7 = '\x01';
                                    *(undefined1 *)(ushort)bVar10 = 0xf0;
                                    bVar10 = bVar10 + 1;
                                  }
                                  *(byte *)(ushort)bVar10 = bVar7;
                                  bVar12 = bVar10 + 1;
                                  if (bVar10 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  bVar10 = bVar12;
                                  if (-1 < (char)BANK0_R3) {
                                    *(byte *)(ushort)bVar12 = BANK0_R3;
                                    bVar7 = bVar12 + 1;
                                    if (bVar12 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    bVar10 = bVar7;
                                    if (-1 < BANK0_R5) {
                                      *(char *)(ushort)bVar7 = BANK0_R5;
                                      bVar10 = bVar7 + 1;
                                      if (bVar7 + 2 == BANK2_R0) {
                                        midi_tx_check_buffer_full();
                                      }
                                      ES = 1;
                                      RS1 = 0;
                                      goto LAB_CODE_1294;
                                    }
                                  }
                                  midi_tx_flush_buffer();
                                }
                              }
                              else if (_c_7 != '\0') {
                                midi_tx_end_sysex();
                              }
                            }
                            else {
                              if (_c_7 != '\0') {
                                midi_tx_end_sysex();
                              }
                              if ((char)bVar8 < '\0') goto LAB_CODE_1371;
                              if (_d_1 != '\x01') {
                                saved_P2_page = 3;
                                P2 = 3;
                                cVar9 = '3';
                                bVar5 = 0;
                                do {
                                  if (-1 < *(char *)(ushort)bVar5) {
                                    *(byte *)(ushort)bVar5 =
                                         current_track_idx >> 4 | current_track_idx << 4 | 0x80 |
                                         bVar8;
                                    *(byte *)(ushort)(bVar5 + 1) = bVar7;
                                    *(byte *)(ushort)(bVar5 + 2) = bVar12;
                                    *(byte *)(ushort)(bVar5 + 3) = bVar13;
                                    bVar10 = bVar5 + 4;
                                    *(byte *)(ushort)bVar10 = bVar6;
                                    if (_d_0 == '\x01') {
                                      RS1 = 1;
                                      saved_P2_page = 0;
                                      P2 = 0;
                                      ES = 0;
                                      if (_c_4 != '\x01') {
                                        TI = 1;
                                        _c_4 = '\x01';
                                      }
                                      *(byte *)(ushort)bVar10 = BANK0_R3 | 0x90;
                                      bVar12 = bVar5 + 5;
                                      if (bVar5 + 6 == BANK2_R0) {
                                        midi_tx_check_buffer_full();
                                      }
                                      *(byte *)(ushort)bVar12 = BANK0_R2;
                                      bVar6 = bVar12 + 1;
                                      if (bVar12 + 2 == BANK2_R0) {
                                        midi_tx_check_buffer_full();
                                      }
                                      *(byte *)(ushort)bVar6 = bVar7;
                                      bVar10 = bVar6 + 1;
                                      if (bVar6 + 2 == BANK2_R0) {
                                        midi_tx_check_buffer_full();
                                      }
                                      ES = 1;
                                      RS1 = 0;
                                    }
                                    break;
                                  }
                                  bVar10 = bVar5 + 5;
                                  cVar9 = cVar9 + -1;
                                  bVar5 = bVar10;
                                } while (cVar9 != '\0');
                              }
                            }
LAB_CODE_1294:
                            if (solo_track_num == current_track_idx) {
                              _f_7 = 1;
                            }
                            bVar12 = *pbVar17;
                          } while (-1 < (char)bVar12);
                          *pcVar4 = (char)((ushort)pbVar17 >> 8);
                          pcVar4[-1] = (char)pbVar17;
                          if (_c_7 != '\0') {
                            midi_tx_end_sysex();
                          }
                        }
                      }
LAB_CODE_1371:
                      current_track_idx = current_track_idx + 1;
                      pcVar3 = pcVar4 + '\x01';
                      if ((byte *)pcVar3 == &current_track_idx) {
                        if (cEXTMEM05d6 != '\0') {
                          cEXTMEM05d6 = cEXTMEM05d6 + -1;
                          goto LAB_CODE_122e;
                        }
                        T0 = 0;
                        active_track_mask = active_track_mask | track_mute_mask;
                        P2 = 3;
                        bVar12 = 0;
                        cVar11 = '3';
                        goto LAB_CODE_1558;
                      }
                      track_bit_rotate = track_bit_rotate << 1 | track_bit_rotate >> 7;
                    } while( true );
                  }
                  if (tick_subdivider != 1) goto LAB_CODE_1146;
                  _e_0 = 1;
                  bVar1 = 0xfe < measure_bcd_lo;
                  measure_bcd_lo = decimal_adjust(measure_bcd_lo + 1);
                  measure_bcd_hi = decimal_adjust(measure_bcd_hi - ((bVar1 << 7) >> 7));
                  if ((measure_bcd_hi != total_measures_hi) || (measure_bcd_lo != total_measures_lo)
                     ) goto LAB_CODE_11e7;
                  if (_f_2 != '\0') {
                    pcVar16 = (char *)0x5cd;
                    cEXTMEM05cd = cEXTMEM05cd + '\x01';
                    get_song_step_data();
                    cEXTMEM00ce = *pcVar16;
                    if (cEXTMEM00ce < '\0') {
                      pcVar16 = (char *)0x5cd;
                      cEXTMEM05cd = '\0';
                      get_song_step_data();
                      cEXTMEM00ce = *pcVar16;
                      if (_f_5 != '\x01') {
                        update_position_display();
                      }
                      if (_d_5 == '\0') {
                        set_default_tempo_values();
                        update_display_full();
                        goto LAB_CODE_11cd;
                      }
                      handle_song_completion();
                    }
                    else {
                      handle_song_completion();
                      if (_f_5 != '\x01') {
                        update_position_display();
                      }
                    }
                    goto LAB_CODE_122b;
                  }
                  F0 = _d_3 & 1;
                  configure_tempo_timer();
                  handle_sequence_boundary();
                  if ((_d_0 != '\x01') && (_d_5 == '\0')) {
LAB_CODE_11cd:
                    _d_7 = 0;
                    stop_all_playing_notes();
                    send_midi_stop_msg();
                    _e_1 = 0;
                    send_midi_song_position();
                    goto LAB_CODE_025f;
                  }
                  track_mute_mask = 0;
                  IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfe;
                  _c_7 = '\0';
                  T0 = 0;
                  cVar11 = F0;
                  if (cVar11 != '\0') {
                    handle_loop_display();
                  }
                }
              }
              configure_tempo_timer();
              send_midi_timing_clock(0xfc);
              handle_sequence_boundary();
            }
            process_playback_buttons();
            if (_0_4 == '\0') {
              if (_0_5 == '\0') {
                if (_c_1 != '\0') {
                  _f_6 = '\x01';
                }
                goto LAB_CODE_0fa0;
              }
              _d_7 = 0;
              stop_all_playing_notes();
              _e_1 = 0;
              goto LAB_CODE_025f;
            }
            send_midi_timing_clock(0xfc);
          } while( true );
        }
        if (((_0_5 != '\0') && (_6_0 != '\x01')) && (_6_1 != '\x01')) {
          if (_c_3 == '\0') {
            _d_1 = '\0';
            _f_5 = '\0';
            if (IO_TRANSPORT_STATE == '\x01') {
              tick_counter = '\0';
            }
            if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) {
              display_ptr_lo = 0x3b;
              display_ptr_hi = 0x16;
              setup_sequence_data_ptrs();
              IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
            }
            else {
              start_recording_new_sequence();
              init_metronome_click();
            }
            setup_recording_state();
            goto LAB_CODE_0f76;
          }
          _c_3 = '\0';
          IO_STATUS_LATCH = IO_STATUS_LATCH | 2;
        }
        if (((tick_counter != '\0') && (IO_TRANSPORT_STATE == '\x02')) && (IO_CLICK_ENABLE != '\0'))
        goto LAB_CODE_02e1;
        check_transport_buttons();
        if (_3_0 != '\0') {
          _d_1 = '\0';
          handle_play_button();
        }
        if (_2_0 != '\0') {
          _d_1 = '\0';
          handle_record_button();
        }
        if (_5_0 != '\0') {
          _d_1 = '\0';
          handle_stop_continue();
        }
        if (_5_7 != '\0') {
          _d_1 = '\0';
          handle_copy_function();
        }
        if (_4_0 != '\0') {
          _d_1 = '\0';
          handle_delete_function();
        }
        if (_3_7 != '\0') {
          _d_1 = '\0';
          handle_midi_channel_filter();
        }
        if (_0_6 != '\0') {
          _d_1 = '\0';
          handle_tempo_edit_button();
        }
        if (_0_1 != '\0') {
          _d_1 = '\0';
          handle_track_select_button();
        }
        if (_0_0 != '\0') {
          _d_1 = '\0';
          handle_track_select_button();
        }
        display_tempo_info();
        check_data_transfer_state();
        display_status_message();
      } while( true );
    }
LAB_CODE_0192:
    *puVar14 = 0xdf;
    lcd_short_delay();
    cVar11 = P1;
    if (cVar11 != -0xd) {
      P2 = 2;
      puVar2 = (undefined1 *)0xff;
      if ((cEXTMEM00fe == '\'') && (cEXTMEM00ff == -0x4b)) goto LAB_CODE_01be;
      goto LAB_CODE_01b1;
    }
    IO_LED_DATA = 0xff;
    IO_STATUS_LATCH = 0xff;
    lcd_print_string(0x7c68);
    pcVar16 = (char *)0x0;
    cVar11 = '\0';
    do {
      *pcVar16 = cVar11;
      pcVar16 = pcVar16 + 1;
      cVar11 = cVar11 + '\x03';
    } while ((char)((ushort)pcVar16 >> 8) != -1);
    pcVar16 = (char *)0x0;
    cVar11 = '\0';
    do {
      cVar9 = *pcVar16;
      if (cVar9 != cVar11) {
        selftest_show_message(0x7c98);
        do {
                    /* WARNING: Do nothing block with infinite loop */
        } while( true );
      }
      pcVar16 = pcVar16 + 1;
      cVar11 = cVar9 + '\x03';
    } while ((char)((ushort)pcVar16 >> 8) != -1);
    lcd_print_string(0x7c88);
    selftest_show_message(0x7ca8);
    bVar12 = 0xfe;
    param_1 = '\x01';
    pbVar18 = (byte *)0x0;
    do {
      pbVar17 = pbVar18;
      bVar1 = CARRY1(*pbVar17,bVar12);
      bVar12 = *pbVar17 + bVar12;
      if (bVar1) {
        param_1 = param_1 + '\x01';
      }
      pbVar18 = pbVar17 + 1;
    } while (((char)pbVar18 != -2) || ((char)((ushort)pbVar18 >> 8) != '\x7f'));
    if ((*pbVar18 != BANK0_R1) || (pbVar17[2] != BANK0_R0)) {
      selftest_show_message(0x7cb8);
      do {
                    /* WARNING: Do nothing block with infinite loop */
      } while( true );
    }
    selftest_show_message(0x7cc8);
    selftest_pass_msg(0x7cd8);
    IO_LED_DATA = 0;
    IO_STATUS_LATCH = 0;
    selftest_delay_loop();
    selftest_delay_loop();
    selftest_delay_loop();
    IO_LED_DATA = 0xff;
    puVar14 = &IO_STATUS_LATCH;
    selftest_ram_rw(0xfe,7);
    *puVar14 = 0xff;
    puVar14 = &IO_LED_DATA;
    selftest_ram_rw(0xfe,8);
    *puVar14 = 0xff;
    RI = 0;
    TI = 0;
    selftest_show_message(0x7d18);
    cVar11 = RI;
    if (cVar11 == '\x01') {
LAB_CODE_7bfc:
      selftest_show_message(0x7d28);
      do {
                    /* WARNING: Do nothing block with infinite loop */
      } while( true );
    }
    SBUF = 0;
    selftest_delay_loop();
    RI = 0;
    SBUF = 0x55;
    selftest_delay_loop();
    cVar11 = RI;
    if ((cVar11 == '\0') || (cVar11 = SBUF, cVar11 != 'U')) goto LAB_CODE_7bfc;
    selftest_show_message(0x7d38);
    IE0 = 0;
    T0 = 0;
    selftest_show_message(0x7ce8);
    cVar11 = IE0;
    if (cVar11 == '\x01') {
LAB_CODE_7c22:
      selftest_show_message(0x7cf8);
      do {
                    /* WARNING: Do nothing block with infinite loop */
      } while( true );
    }
    T0 = 1;
    selftest_delay_loop();
    cVar11 = IE0;
    if (cVar11 == '\0') goto LAB_CODE_7c22;
    selftest_show_message(0x7d08);
  } while( true );
LAB_CODE_1558:
  do {
    bVar10 = *(byte *)(ushort)bVar12;
    if ((char)bVar10 < '\0') {
      bVar7 = bVar12 + 3;
      cVar9 = *(char *)(ushort)bVar7;
      *(char *)(ushort)bVar7 = cVar9 + -1;
      if (cVar9 + -1 != '\0') goto LAB_CODE_155f;
      cVar9 = *(char *)(ushort)(bVar12 + 4);
      if (cVar9 == '\0') {
        bVar8 = bVar12 + 1;
        *(undefined1 *)(ushort)bVar12 = 0;
        cVar9 = ((bVar10 & 0x70) >> 4) + 1;
        bVar7 = 0x80;
        bVar6 = 0;
        do {
          bVar13 = bVar6 << 1 | bVar7 >> 7;
          bVar7 = bVar6 & 0x80;
          cVar9 = cVar9 + -1;
          bVar6 = bVar13;
        } while (cVar9 != '\0');
        if ((bVar13 & active_track_mask) != 0) {
          RS1 = 1;
          saved_P2_page = 0;
          P2 = 0;
          ES = 0;
          if (_c_4 != '\x01') {
            TI = 1;
            _c_4 = '\x01';
          }
          *(byte *)(ushort)bVar12 = BANK0_R3 | 0x80;
          if (bVar12 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full(*(undefined1 *)(ushort)(bVar12 + 2),bVar10 & 0xf);
          }
          *(byte *)(ushort)bVar8 = BANK0_R2;
          bVar10 = bVar8 + 1;
          if (bVar8 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full();
          }
          *(undefined1 *)(ushort)bVar10 = 0x40;
          bVar12 = bVar10 + 1;
          if (bVar10 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full();
          }
          ES = 1;
          RS1 = 0;
          P2 = 3;
        }
        goto LAB_CODE_155c;
      }
      *(char *)(ushort)(bVar12 + 4) = cVar9 + -1;
      bVar12 = bVar12 + 5;
    }
    else {
LAB_CODE_155c:
      bVar7 = bVar12 + 3;
LAB_CODE_155f:
      bVar12 = bVar7 + 2;
    }
    cVar11 = cVar11 + -1;
    saved_P2_page = 3;
  } while (cVar11 != '\0');
  goto LAB_CODE_1076;
}



/* ====================================================================== */
/* Function at 0x055E: scan_keyboard */
/* ====================================================================== */

/* Scan 6-column keyboard matrix via HC574 latch.
   Writes column selects to XDATA 0xFF06, reads rows from P1.
   Debounces: rejects if >2 keys in any column (sets _d_2).
   Stores raw scan in IRAM 0x26-0x2B, computes edge-detect
     (new keypresses) in IRAM 0x20-0x25 via XOR with previous state.
   Also reads P3.3 (external start/stop input) into _8_4 flag.
   Key repeat: auto-repeats after 0x80 ticks if held, then every 0x14 ticks. */

void scan_keyboard(void)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  byte *pbVar4;
  char cVar5;
  byte bVar6;
  byte bVar7;
  undefined1 *puVar8;
  
  bVar2 = key_scan_col2;
  puVar8 = &IO_KEY_COLUMN_SEL;
  IO_KEY_COLUMN_SEL = 0x80;
  io_settle_delay();
  cVar5 = P1;
  if (cVar5 == -1) {
    _d_2 = 0;
    DAT_INTMEM_55 = 0;
    DAT_INTMEM_56 = 0;
    DAT_INTMEM_57 = 0;
    DAT_INTMEM_58 = 0;
    DAT_INTMEM_59 = 0;
    DAT_INTMEM_5a = 0;
    key_scan_col0 = 0;
    key_scan_col1 = 0;
    key_scan_col2 = 0;
    key_scan_col3 = 0;
    key_scan_col4 = 0;
    key_scan_col5 = 0;
    key_repeat_timer = -0x80;
LAB_CODE_058c:
    key_edge_col0 = 0;
    key_edge_col1 = 0;
    key_edge_col2 = 0;
    key_edge_col3 = 0;
    key_edge_col4 = 0;
    key_edge_col5 = 0;
  }
  else {
    *puVar8 = 0xff;
    cVar5 = '\x06';
    bVar6 = 0;
    pbVar3 = &key_scan_col0;
    bVar7 = 0xfe;
    nop();
    nop();
    nop();
    nop();
    nop();
    do {
      puVar8 = &IO_KEY_COLUMN_SEL;
      IO_KEY_COLUMN_SEL = bVar7;
      io_settle_delay();
      bVar1 = P1;
      *pbVar3 = ~bVar1;
      *puVar8 = 0xff;
      bVar1 = *pbVar3;
      pbVar3 = pbVar3 + '\x01';
      bVar6 = *(char *)((ushort)bVar1 + 0x66b) + bVar6;
      bVar7 = bVar7 << 1 | bVar7 >> 7;
      if (2 < bVar6) {
        _d_2 = 1;
        goto LAB_CODE_058c;
      }
      cVar5 = cVar5 + -1;
    } while (cVar5 != '\0');
    _d_2 = 0;
    pbVar3 = &DAT_INTMEM_55;
    pbVar4 = &key_edge_col0;
    BANK1_R0 = 0x26;
    cVar5 = '\x06';
    do {
      RS0 = 1;
      bVar6 = *pbVar3;
      RS0 = 0;
      bVar7 = pbVar3['\x01'];
      pbVar3['\x01'] = bVar6;
      *pbVar4 = (bVar6 ^ bVar7) & bVar6;
      pbVar3 = pbVar3 + '\x02';
      pbVar4 = pbVar4 + '\x01';
      cVar5 = cVar5 + -1;
    } while (cVar5 != '\0');
    if (_8_2 == '\x01') {
      key_repeat_timer = key_repeat_timer + -1;
      if (key_repeat_timer == '\0') {
        key_repeat_timer = '\x14';
        _2_2 = 1;
      }
    }
    else if (_8_1 == '\x01') {
      key_repeat_timer = key_repeat_timer + -1;
      if (key_repeat_timer == '\0') {
        key_repeat_timer = '\x14';
        _2_1 = 1;
      }
    }
    else if ((_6_1 != '\x01') && (_6_0 != '\x01')) {
      key_repeat_timer = -0x80;
    }
  }
  bVar6 = P3;
  if (_c_0 != '\x01') {
    bVar6 = ~bVar6;
  }
  bVar6 = bVar6 & 8;
  key_scan_col2 = key_scan_col2 & 0xf7 | bVar6;
  if (((bVar2 ^ bVar6) & bVar6) == 0) {
    _8_4 = 0;
    return;
  }
  _8_4 = 1;
  return;
}



/* ====================================================================== */
/* Function at 0x0634: display_status_message */
/* ====================================================================== */

/* Display context-sensitive status message on LCD.
   Selects message string based on button state flags (_2_0, _3_0, _4_0).
   Calls lcd_print_string with address from CODE memory lookup table. */

void display_status_message(void)

{
  undefined2 uVar1;
  
  if (_b_7 != '\0') {
    if (_2_0 == '\0') {
      if (_3_0 == '\0') {
        if (_4_0 == '\0') {
          return;
        }
        uVar1 = 0x25ab;
      }
      else {
        uVar1 = 0x2309;
      }
    }
    else {
      uVar1 = 0x24df;
    }
    lcd_print_string(uVar1);
  }
  return;
}



/* ====================================================================== */
/* Function at 0x0653: io_settle_delay */
/* ====================================================================== */

/* 6x NOP delay for I/O bus settling time after writing to HC574 latches. */

void io_settle_delay(void)

{
  nop();
  nop();
  nop();
  nop();
  nop();
  nop();
  return;
}



/* ====================================================================== */
/* Function at 0x065A: lcd_short_delay */
/* ====================================================================== */

/* Short delay loop (27 iterations) for HD44780 LCD command timing (~40us). */

void lcd_short_delay(void)

{
  char cVar1;
  
  cVar1 = '\x1b';
  do {
    cVar1 = cVar1 + -1;
  } while (cVar1 != '\0');
  nop();
  return;
}



/* ====================================================================== */
/* Function at 0x0661: lcd_long_delay */
/* ====================================================================== */

/* Long delay (calls lcd_short_delay 39 times) for LCD power-on init (~4.1ms). */

void lcd_long_delay(void)

{
  char cVar1;
  
  cVar1 = '\'';
  do {
    lcd_short_delay();
    cVar1 = cVar1 + -1;
  } while (cVar1 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x076B: stop_track_playback */
/* ====================================================================== */

/* Stop current track playback and clean up.
   If playing (_c_3): sends all-notes-off via midi_tx_note_off,
     clears _c_3, restores position pointers (0x73/0x74), clears track mask.
   If not playing: checks for auto-stop conditions. */

void stop_track_playback(void)

{
  char *pcVar1;
  undefined1 uVar2;
  byte bVar3;
  byte bVar4;
  char cVar5;
  
  if (_c_3 != '\x01') {
    if (_d_3 != '\0') {
      return;
    }
    if (cEXTMEM04d4 != '\0') {
      if (cEXTMEM04cc != '\0') {
        track_mute_mask = *(undefined1 *)((ushort)(cEXTMEM04cc - 1U) + 0x910);
        _d_3 = 1;
        cVar5 = (cEXTMEM04cc - 1U) * '\x02';
        seq_start_ptr_lo = *(undefined1 *)(cVar5 + ']');
        seq_start_ptr_hi = *(undefined1 *)(cVar5 + '^');
        IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfd;
        _c_3 = 1;
        clear_track_event_buffers();
        bVar3 = 0xbe;
        cVar5 = ' ';
        do {
          *(undefined1 *)(ushort)bVar3 = 0;
          bVar3 = bVar3 + 2;
          cVar5 = cVar5 + -1;
        } while (cVar5 != '\0');
        return;
      }
      return;
    }
    return;
  }
  if ((_d_6 != '\0') && (BANK2_R2 != -1)) {
    bVar3 = 0xbe;
    BANK3_R2 = 0x40;
    do {
      saved_P2_page = 2;
      P2 = 2;
      while( true ) {
        pcVar1 = (char *)(ushort)bVar3;
        bVar4 = bVar3 + 1;
        if (*pcVar1 != '\0') break;
        bVar3 = bVar3 + 2;
        if (bVar3 == 0xfe) goto LAB_CODE_07ec;
      }
      bVar3 = bVar3 + 2;
      RS1 = 1;
      uVar2 = DAT_INTMEM_79;
      DAT_INTMEM_79 = *(byte *)CONCAT11(*pcVar1,*(undefined1 *)(ushort)bVar4) & 0x7f;
      midi_tx_note_off(0x80);
      RS0 = 0;
      RS1 = 0;
    } while (bVar3 != 0xfe);
  }
LAB_CODE_07ec:
  _c_3 = 0;
  cVar5 = (cEXTMEM04cc + -1) * '\x02';
  playback_ptr_lo = *(undefined1 *)(cVar5 + ']');
  playback_ptr_hi = *(undefined1 *)(cVar5 + '^');
  track_mute_mask = 0;
  IO_STATUS_LATCH = IO_STATUS_LATCH | 2;
  return;
}



/* ====================================================================== */
/* Function at 0x0772: start_track_playback */
/* ====================================================================== */

/* Start playback of current track.
   Loads track mask from sequence data at XDATA (04CC-related),
   sets _d_3 (sequence loaded), _c_3 (playing), clears note buffer.
   Only starts if track has data (04D4 != 0) and track is selected (04CC != 0). */

void start_track_playback(void)

{
  byte bVar1;
  char cVar2;
  
  if (cEXTMEM04d4 == '\0') {
    return;
  }
  if (cEXTMEM04cc == '\0') {
    return;
  }
  track_mute_mask = *(undefined1 *)((ushort)(cEXTMEM04cc - 1U) + 0x910);
  _d_3 = 1;
  cVar2 = (cEXTMEM04cc - 1U) * '\x02';
  seq_start_ptr_lo = *(undefined1 *)(cVar2 + ']');
  seq_start_ptr_hi = *(undefined1 *)(cVar2 + '^');
  IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfd;
  _c_3 = 1;
  clear_track_event_buffers();
  bVar1 = 0xbe;
  cVar2 = ' ';
  do {
    *(undefined1 *)(ushort)bVar1 = 0;
    bVar1 = bVar1 + 2;
    cVar2 = cVar2 + -1;
  } while (cVar2 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x07AC: all_notes_off_cleanup */
/* ====================================================================== */

/* Send note-off for all active notes and clean up playback state.
   Iterates through active note table at IRAM 0xBE-0xFD,
   sends note-off for each, clears _c_3, restores pointers. */

void all_notes_off_cleanup(void)

{
  char *pcVar1;
  char cVar2;
  undefined1 uVar3;
  byte bVar4;
  byte bVar5;
  
  if ((_d_6 != '\0') && (BANK2_R2 != -1)) {
    bVar4 = 0xbe;
    BANK3_R2 = 0x40;
    do {
      saved_P2_page = 2;
      P2 = 2;
      while( true ) {
        pcVar1 = (char *)(ushort)bVar4;
        bVar5 = bVar4 + 1;
        if (*pcVar1 != '\0') break;
        bVar4 = bVar4 + 2;
        if (bVar4 == 0xfe) goto LAB_CODE_07ec;
      }
      bVar4 = bVar4 + 2;
      RS1 = 1;
      uVar3 = DAT_INTMEM_79;
      DAT_INTMEM_79 = *(byte *)CONCAT11(*pcVar1,*(undefined1 *)(ushort)bVar5) & 0x7f;
      midi_tx_note_off(0x80);
      RS0 = 0;
      RS1 = 0;
    } while (bVar4 != 0xfe);
  }
LAB_CODE_07ec:
  _c_3 = 0;
  cVar2 = (cEXTMEM04cc + -1) * '\x02';
  playback_ptr_lo = *(undefined1 *)(cVar2 + ']');
  playback_ptr_hi = *(undefined1 *)(cVar2 + '^');
  track_mute_mask = 0;
  IO_STATUS_LATCH = IO_STATUS_LATCH | 2;
  return;
}



/* ====================================================================== */
/* Function at 0x0808: clear_track_event_buffers */
/* ====================================================================== */

/* Clear all track event input buffers in XDATA page 2.
   Sets P2=2, clears offsets 0x00, 0x1F, 0x34, 0x6B, 0xA2, 0xBB.
   Clears _f_3 (external trigger flag). Called on stop and mode changes. */

void clear_track_event_buffers(void)

{
  saved_P2_page = 2;
  P2 = 2;
  uEXTMEM0000 = 0;
  uEXTMEM001f = 0;
  uEXTMEM0034 = 0;
  uEXTMEM006b = 0;
  uEXTMEM00a2 = 0;
  uEXTMEM00bb = 0;
  _f_3 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x0824: advance_playback_position */
/* ====================================================================== */

/* Advance sequence playback position and update counters.
   Computes position delta, updates BCD measure/beat counters
   (IRAM 0x51/0x52) with decimal_adjust for display.
   Handles sequence boundaries and tempo recalculation. */

void advance_playback_position(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  char cVar5;
  byte bVar6;
  char cVar7;
  byte *pbVar8;
  char *pcVar9;
  
  saved_P2_page = 4;
  P2 = 4;
  current_track_idx = playback_ptr_lo;
  active_track_mask = playback_ptr_hi;
  track_bit_rotate = record_ptr_lo;
  track_mute_mask = record_ptr_hi;
  compute_position_delta
            (bEXTMEM00cf - playback_ptr_lo,
             cEXTMEM00d0 - (playback_ptr_hi - (((bEXTMEM00cf < playback_ptr_lo) << 7) >> 7)));
  sequence_data_seek(seq_start_ptr_lo,seq_start_ptr_hi,record_ptr_lo - playback_ptr_lo,
                     record_ptr_hi -
                     (playback_ptr_hi - (((record_ptr_lo < playback_ptr_lo) << 7) >> 7)));
  bVar3 = measure_bcd_lo;
  bVar4 = playback_ptr_lo - seq_start_ptr_lo;
  cVar5 = playback_ptr_hi - (seq_start_ptr_hi - (((playback_ptr_lo < seq_start_ptr_lo) << 7) >> 7));
  bVar6 = (record_ptr_lo - bEXTMEM00cf) - bVar4;
  cVar7 = (record_ptr_hi - (cEXTMEM00d0 - (((record_ptr_lo < bEXTMEM00cf) << 7) >> 7))) -
          (cVar5 - (((record_ptr_lo - bEXTMEM00cf < bVar4) << 7) >> 7));
  bVar1 = bEXTMEM00d3 < bVar6;
  bEXTMEM00d3 = bEXTMEM00d3 - bVar6;
  cEXTMEM00d4 = cEXTMEM00d4 - (cVar7 - ((bVar1 << 7) >> 7));
  if (cEXTMEM00cc == '\x01') {
    pbVar8 = (byte *)CONCAT11(*(undefined1 *)(ushort)(byte)(cEXTMEM00ca * '\x02'),
                              *(undefined1 *)(ushort)(cEXTMEM00ca * '\x02' + 1));
    bVar2 = *pbVar8;
    *pbVar8 = bVar2 + bVar6;
    pbVar8[1] = pbVar8[1] + (cVar7 - ((CARRY1(bVar2,bVar6) << 7) >> 7));
  }
  bEXTMEM00cf = record_ptr_lo - bVar4;
  cEXTMEM00d0 = record_ptr_hi - (cVar5 - (((record_ptr_lo < bVar4) << 7) >> 7));
  _d_3 = 0;
  bVar4 = *(byte *)(ushort)(cEXTMEM00ca * '\x02' + 1);
  pcVar9 = (char *)CONCAT11(*(char *)(ushort)(byte)(cEXTMEM00ca * '\x02') -
                            (((0xed < bVar4) << 7) >> 7),bVar4 + 0x12);
  if ((*pcVar9 == '\0') && (pcVar9 = pcVar9 + 1, *pcVar9 == '\0')) {
    if (tick_subdivider < 0x30) {
      bVar1 = 0xfe < measure_bcd_lo;
      measure_bcd_lo = decimal_adjust(measure_bcd_lo + 1);
      measure_bcd_hi = decimal_adjust(measure_bcd_hi - ((bVar1 << 7) >> 7));
    }
    if ((measure_bcd_hi == '\0') && ((measure_bcd_lo == 0 || (measure_bcd_lo == 1)))) {
      measure_bcd_lo = 2;
    }
    if ((measure_bcd_hi == '\x06') && (measure_bcd_lo == 0x84)) {
      measure_bcd_lo = 0x83;
    }
    *pcVar9 = measure_bcd_hi;
    *(byte *)CONCAT11((char)((ushort)pcVar9 >> 8) + ((((char)pcVar9 == '\0') << 7) >> 7),
                      (char)pcVar9 + -1) = measure_bcd_lo;
    bVar6 = bVar3;
  }
  recalculate_sequence_length(bVar6);
  load_sequence_from_storage();
  return;
}



/* ====================================================================== */
/* Function at 0x0918: process_recording_realtime */
/* ====================================================================== */

/* Process MIDI events for real-time recording.
   Sets _c_2=1 (realtime mode). Reads incoming MIDI data from
   track event buffers, timestamps with clock counter,
   and appends to sequence data in XDATA. */

void process_recording_realtime(void)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte *pbVar7;
  undefined1 *puVar8;
  byte *pbVar9;
  
  bVar1 = bEXTMEM0000;
  _c_2 = '\x01';
  if (_c_6 != '\x01') {
    _c_1 = '\0';
  }
  current_track_idx = uEXTMEM04d1;
  pbVar7 = (byte *)0x4d2;
  active_track_mask = cEXTMEM04d2 + -1;
  saved_P2_page = 2;
  P2 = 2;
  if (_c_6 == '\0') {
    if (bEXTMEM0000 != 0) {
      bEXTMEM0000 = 0;
      bVar4 = 0;
      do {
        sequence_playback_engine();
        bVar2 = bVar4 + 1;
        bVar6 = *(byte *)(ushort)bVar2;
        if (_c_1 != '\x01') {
          bVar6 = bVar6 | 0x80;
        }
        *pbVar7 = bVar6;
        bVar6 = 0xbe;
        cVar3 = ' ';
        do {
          if (*(char *)(ushort)bVar6 == '\0') {
            *(char *)(ushort)bVar6 = (char)((ushort)pbVar7 >> 8);
            *(char *)(ushort)(bVar6 + 1) = (char)pbVar7;
            pbVar9 = pbVar7 + 1;
            if (_c_1 != '\x01') {
              _c_1 = '\x01';
              *pbVar9 = midi_clock_lo;
              pbVar7[2] = midi_clock_hi;
              pbVar9 = pbVar7 + 3;
            }
            *pbVar9 = *(byte *)(ushort)(bVar4 + 2);
            bVar2 = bVar4 + 3;
            pbVar9[1] = *(byte *)(ushort)bVar2;
            pbVar9[2] = 0;
            pbVar9[3] = 1;
            pbVar7 = pbVar9 + 4;
            bVar5 = bVar1;
            break;
          }
          bVar6 = bVar6 + 2;
          cVar3 = cVar3 + -1;
          bVar5 = bVar2;
        } while (cVar3 != '\0');
        record_ptr_hi = (undefined1)((ushort)pbVar7 >> 8);
        record_ptr_lo = SUB21(pbVar7,0);
        bVar4 = bVar2;
      } while (bVar5 != BANK0_R0);
    }
    bVar1 = 0xbe;
    do {
      while( true ) {
        if (*(char *)(ushort)bVar1 != '\0') break;
joined_c0x09ac:
        bVar1 = bVar1 + 2;
        if (bVar1 == 0xfe) goto LAB_CODE_0a02;
      }
      pbVar9 = (byte *)CONCAT11(*(char *)(ushort)bVar1,*(undefined1 *)(ushort)(bVar1 + 1));
      bVar4 = *pbVar9;
      if ((char)bVar4 < '\0') {
        bVar4 = bVar4 & 0x7f;
        pbVar9 = pbVar9 + 2;
      }
      pbVar7 = pbVar9 + 2;
      bVar6 = 0x1f;
      do {
        if (cEXTMEM001f + 0x1fU == BANK0_R0) {
          if (_c_2 != '\0') {
            pbVar7 = pbVar9 + 4;
            bVar4 = *pbVar7;
            *pbVar7 = bVar4 + 1;
            pbVar7 = (byte *)CONCAT11((char)((ushort)(pbVar9 + 3) >> 8),(char)pbVar7 + -1);
            if ((bVar4 + 1 == 1) && (-1 < (char)(*pbVar7 + 1))) {
              *pbVar7 = *pbVar7 + 1;
            }
          }
          goto joined_c0x09ac;
        }
        bVar2 = bVar6 + 1;
        bVar6 = bVar6 + 2;
      } while ((*(byte *)(ushort)bVar2 != bVar4) || (*(char *)(ushort)bVar6 != BANK0_R2));
      *(undefined1 *)(ushort)bVar6 = 0x11;
      *(undefined1 *)(ushort)bVar1 = 0;
      bVar1 = bVar1 + 2;
    } while (bVar1 != 0xfe);
LAB_CODE_0a02:
    cEXTMEM001f = '\0';
    bVar1 = 0x34;
    pbVar9 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo);
    if (cEXTMEM0034 != '\0') {
      bVar4 = cEXTMEM0034 + 0x34;
      cEXTMEM0034 = '\0';
      do {
        record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
        record_ptr_lo = SUB21(pbVar9,0);
        sequence_playback_engine();
        bVar6 = *(byte *)(ushort)(bVar1 + 1);
        if (_c_1 != '\x01') {
          bVar6 = bVar6 | 0x80;
        }
        *pbVar7 = bVar6;
        pbVar9 = pbVar7 + 1;
        if (_c_1 != '\x01') {
          _c_1 = '\x01';
          *pbVar9 = midi_clock_lo;
          pbVar7[2] = midi_clock_hi;
          pbVar9 = pbVar7 + 3;
        }
        *pbVar9 = *(byte *)(ushort)(bVar1 + 2) | 0x80;
        bVar1 = bVar1 + 3;
        pbVar9[1] = *(byte *)(ushort)bVar1;
        pbVar9[2] = 0;
        pbVar7 = pbVar9 + 4;
        pbVar9 = pbVar7;
      } while (bVar4 != BANK0_R0);
    }
    bVar1 = 0x6b;
    if (cEXTMEM006b != '\0') {
      bVar4 = cEXTMEM006b + 0x6b;
      cEXTMEM006b = '\0';
      do {
        record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
        record_ptr_lo = SUB21(pbVar9,0);
        sequence_playback_engine();
        bVar6 = 0x7c;
        if (_c_1 != '\x01') {
          bVar6 = 0xfc;
        }
        *pbVar7 = bVar6;
        pbVar9 = pbVar7 + 1;
        if (_c_1 != '\x01') {
          _c_1 = '\x01';
          *pbVar9 = midi_clock_lo;
          pbVar7[2] = midi_clock_hi;
          pbVar9 = pbVar7 + 3;
        }
        *pbVar9 = 0x80;
        bVar6 = *(byte *)(ushort)(bVar1 + 1);
        bVar2 = *(byte *)(ushort)(bVar1 + 2);
        bVar1 = bVar1 + 3;
        pbVar9[1] = *(byte *)(ushort)bVar1;
        pbVar9[2] = bVar6;
        pbVar9[3] = bVar2;
        pbVar7 = pbVar9 + 4;
        pbVar9 = pbVar7;
      } while (bVar4 != BANK0_R0);
    }
    bVar1 = 0xa2;
    if (cEXTMEM00a2 != '\0') {
      _c_6 = '\x01';
      bVar4 = cEXTMEM00a2 + 0xa2;
      cEXTMEM00a2 = '\0';
      goto LAB_CODE_0a8e;
    }
  }
  else {
    bVar1 = 0xa2;
    if (cEXTMEM00a2 != '\0') {
      bVar4 = cEXTMEM00a2 + 0xa2;
      cEXTMEM00a2 = '\0';
      pbVar7 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo);
      do {
        pbVar9 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo);
        if (sysex_byte_count == '\0') {
LAB_CODE_0a8e:
          record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
          record_ptr_lo = SUB21(pbVar9,0);
          sequence_playback_engine();
          bVar6 = 0x7d;
          if (_c_1 != '\x01') {
            bVar6 = 0xfd;
          }
          *pbVar7 = bVar6;
          pbVar9 = pbVar7 + 1;
          if (_c_1 != '\x01') {
            _c_1 = '\x01';
            *pbVar9 = midi_clock_lo;
            pbVar7[2] = midi_clock_hi;
            pbVar9 = pbVar7 + 3;
          }
          sysex_byte_count = '\x01';
          bVar1 = bVar1 + 1;
          *pbVar9 = *(byte *)(ushort)bVar1 | 0x80;
          pbVar9 = pbVar9 + 1;
        }
        else {
          bVar1 = bVar1 + 1;
          *pbVar7 = *(byte *)(ushort)bVar1;
          pbVar9 = pbVar7 + 1;
          sysex_byte_count = sysex_byte_count + '\x01';
          if (sysex_byte_count == '\x02') {
            *pbVar9 = 2;
            pbVar9 = pbVar7 + 2;
          }
          if (sysex_byte_count == '\x03') {
            sysex_byte_count = '\0';
          }
        }
        record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
        record_ptr_lo = SUB21(pbVar9,0);
        pbVar7 = pbVar9;
      } while (bVar4 != BANK0_R0);
    }
    pbVar9 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo);
    if ((_c_5 != '\x01') &&
       (_c_6 = '\0', pbVar9 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo),
       sysex_byte_count != '\0')) {
      puVar8 = (undefined1 *)CONCAT11(record_ptr_hi,record_ptr_lo);
      *puVar8 = 0x80;
      if (sysex_byte_count == '\x01') {
        puVar8[1] = 1;
        puVar8 = puVar8 + 2;
      }
      pbVar9 = puVar8 + 1;
    }
  }
  record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
  record_ptr_lo = SUB21(pbVar9,0);
  return;
}



/* ====================================================================== */
/* Function at 0x0922: process_recording_step */
/* ====================================================================== */

/* Process MIDI events for step recording.
   Sets _c_2=0 (step mode). Similar to realtime but advances
   position by fixed step size rather than real time. */

void process_recording_step(void)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte *pbVar7;
  undefined1 *puVar8;
  byte *pbVar9;
  
  bVar1 = bEXTMEM0000;
  _c_2 = '\0';
  current_track_idx = uEXTMEM04d1;
  pbVar7 = (byte *)0x4d2;
  active_track_mask = cEXTMEM04d2 + -1;
  saved_P2_page = 2;
  P2 = 2;
  if (_c_6 == '\0') {
    if (bEXTMEM0000 != 0) {
      bEXTMEM0000 = 0;
      bVar4 = 0;
      do {
        sequence_playback_engine();
        bVar2 = bVar4 + 1;
        bVar6 = *(byte *)(ushort)bVar2;
        if (_c_1 != '\x01') {
          bVar6 = bVar6 | 0x80;
        }
        *pbVar7 = bVar6;
        bVar6 = 0xbe;
        cVar3 = ' ';
        do {
          if (*(char *)(ushort)bVar6 == '\0') {
            *(char *)(ushort)bVar6 = (char)((ushort)pbVar7 >> 8);
            *(char *)(ushort)(bVar6 + 1) = (char)pbVar7;
            pbVar9 = pbVar7 + 1;
            if (_c_1 != '\x01') {
              _c_1 = '\x01';
              *pbVar9 = midi_clock_lo;
              pbVar7[2] = midi_clock_hi;
              pbVar9 = pbVar7 + 3;
            }
            *pbVar9 = *(byte *)(ushort)(bVar4 + 2);
            bVar2 = bVar4 + 3;
            pbVar9[1] = *(byte *)(ushort)bVar2;
            pbVar9[2] = 0;
            pbVar9[3] = 1;
            pbVar7 = pbVar9 + 4;
            bVar5 = bVar1;
            break;
          }
          bVar6 = bVar6 + 2;
          cVar3 = cVar3 + -1;
          bVar5 = bVar2;
        } while (cVar3 != '\0');
        record_ptr_hi = (undefined1)((ushort)pbVar7 >> 8);
        record_ptr_lo = SUB21(pbVar7,0);
        bVar4 = bVar2;
      } while (bVar5 != BANK0_R0);
    }
    bVar1 = 0xbe;
    do {
      while( true ) {
        if (*(char *)(ushort)bVar1 != '\0') break;
joined_c0x09ac:
        bVar1 = bVar1 + 2;
        if (bVar1 == 0xfe) goto LAB_CODE_0a02;
      }
      pbVar9 = (byte *)CONCAT11(*(char *)(ushort)bVar1,*(undefined1 *)(ushort)(bVar1 + 1));
      bVar4 = *pbVar9;
      if ((char)bVar4 < '\0') {
        bVar4 = bVar4 & 0x7f;
        pbVar9 = pbVar9 + 2;
      }
      pbVar7 = pbVar9 + 2;
      bVar6 = 0x1f;
      do {
        if (cEXTMEM001f + 0x1fU == BANK0_R0) {
          if (_c_2 != '\0') {
            pbVar7 = pbVar9 + 4;
            bVar4 = *pbVar7;
            *pbVar7 = bVar4 + 1;
            pbVar7 = (byte *)CONCAT11((char)((ushort)(pbVar9 + 3) >> 8),(char)pbVar7 + -1);
            if ((bVar4 + 1 == 1) && (-1 < (char)(*pbVar7 + 1))) {
              *pbVar7 = *pbVar7 + 1;
            }
          }
          goto joined_c0x09ac;
        }
        bVar2 = bVar6 + 1;
        bVar6 = bVar6 + 2;
      } while ((*(byte *)(ushort)bVar2 != bVar4) || (*(char *)(ushort)bVar6 != BANK0_R2));
      *(undefined1 *)(ushort)bVar6 = 0x11;
      *(undefined1 *)(ushort)bVar1 = 0;
      bVar1 = bVar1 + 2;
    } while (bVar1 != 0xfe);
LAB_CODE_0a02:
    cEXTMEM001f = '\0';
    bVar1 = 0x34;
    pbVar9 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo);
    if (cEXTMEM0034 != '\0') {
      bVar4 = cEXTMEM0034 + 0x34;
      cEXTMEM0034 = '\0';
      do {
        record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
        record_ptr_lo = SUB21(pbVar9,0);
        sequence_playback_engine();
        bVar6 = *(byte *)(ushort)(bVar1 + 1);
        if (_c_1 != '\x01') {
          bVar6 = bVar6 | 0x80;
        }
        *pbVar7 = bVar6;
        pbVar9 = pbVar7 + 1;
        if (_c_1 != '\x01') {
          _c_1 = '\x01';
          *pbVar9 = midi_clock_lo;
          pbVar7[2] = midi_clock_hi;
          pbVar9 = pbVar7 + 3;
        }
        *pbVar9 = *(byte *)(ushort)(bVar1 + 2) | 0x80;
        bVar1 = bVar1 + 3;
        pbVar9[1] = *(byte *)(ushort)bVar1;
        pbVar9[2] = 0;
        pbVar7 = pbVar9 + 4;
        pbVar9 = pbVar7;
      } while (bVar4 != BANK0_R0);
    }
    bVar1 = 0x6b;
    if (cEXTMEM006b != '\0') {
      bVar4 = cEXTMEM006b + 0x6b;
      cEXTMEM006b = '\0';
      do {
        record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
        record_ptr_lo = SUB21(pbVar9,0);
        sequence_playback_engine();
        bVar6 = 0x7c;
        if (_c_1 != '\x01') {
          bVar6 = 0xfc;
        }
        *pbVar7 = bVar6;
        pbVar9 = pbVar7 + 1;
        if (_c_1 != '\x01') {
          _c_1 = '\x01';
          *pbVar9 = midi_clock_lo;
          pbVar7[2] = midi_clock_hi;
          pbVar9 = pbVar7 + 3;
        }
        *pbVar9 = 0x80;
        bVar6 = *(byte *)(ushort)(bVar1 + 1);
        bVar2 = *(byte *)(ushort)(bVar1 + 2);
        bVar1 = bVar1 + 3;
        pbVar9[1] = *(byte *)(ushort)bVar1;
        pbVar9[2] = bVar6;
        pbVar9[3] = bVar2;
        pbVar7 = pbVar9 + 4;
        pbVar9 = pbVar7;
      } while (bVar4 != BANK0_R0);
    }
    bVar1 = 0xa2;
    if (cEXTMEM00a2 != '\0') {
      _c_6 = '\x01';
      bVar4 = cEXTMEM00a2 + 0xa2;
      cEXTMEM00a2 = '\0';
      goto LAB_CODE_0a8e;
    }
  }
  else {
    bVar1 = 0xa2;
    if (cEXTMEM00a2 != '\0') {
      bVar4 = cEXTMEM00a2 + 0xa2;
      cEXTMEM00a2 = '\0';
      pbVar7 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo);
      do {
        pbVar9 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo);
        if (sysex_byte_count == '\0') {
LAB_CODE_0a8e:
          record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
          record_ptr_lo = SUB21(pbVar9,0);
          sequence_playback_engine();
          bVar6 = 0x7d;
          if (_c_1 != '\x01') {
            bVar6 = 0xfd;
          }
          *pbVar7 = bVar6;
          pbVar9 = pbVar7 + 1;
          if (_c_1 != '\x01') {
            _c_1 = '\x01';
            *pbVar9 = midi_clock_lo;
            pbVar7[2] = midi_clock_hi;
            pbVar9 = pbVar7 + 3;
          }
          sysex_byte_count = '\x01';
          bVar1 = bVar1 + 1;
          *pbVar9 = *(byte *)(ushort)bVar1 | 0x80;
          pbVar9 = pbVar9 + 1;
        }
        else {
          bVar1 = bVar1 + 1;
          *pbVar7 = *(byte *)(ushort)bVar1;
          pbVar9 = pbVar7 + 1;
          sysex_byte_count = sysex_byte_count + '\x01';
          if (sysex_byte_count == '\x02') {
            *pbVar9 = 2;
            pbVar9 = pbVar7 + 2;
          }
          if (sysex_byte_count == '\x03') {
            sysex_byte_count = '\0';
          }
        }
        record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
        record_ptr_lo = SUB21(pbVar9,0);
        pbVar7 = pbVar9;
      } while (bVar4 != BANK0_R0);
    }
    pbVar9 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo);
    if ((_c_5 != '\x01') &&
       (_c_6 = '\0', pbVar9 = (byte *)CONCAT11(record_ptr_hi,record_ptr_lo),
       sysex_byte_count != '\0')) {
      puVar8 = (undefined1 *)CONCAT11(record_ptr_hi,record_ptr_lo);
      *puVar8 = 0x80;
      if (sysex_byte_count == '\x01') {
        puVar8[1] = 1;
        puVar8 = puVar8 + 2;
      }
      pbVar9 = puVar8 + 1;
    }
  }
  record_ptr_hi = (undefined1)((ushort)pbVar9 >> 8);
  record_ptr_lo = SUB21(pbVar9,0);
  return;
}



/* ====================================================================== */
/* Function at 0x0AF5: sequence_playback_engine */
/* ====================================================================== */

/* CORE SEQUENCER PLAYBACK ENGINE (1513 bytes - largest function).
   Iterates through all 8 tracks, reads timestamped MIDI events
   from sequence data in XDATA, outputs events whose timestamps
   match the current playback position.
   
   MIDI event dispatch based on status byte type (BANK0_R2):
     < 0x7A: Note On/Off (status | 0x90/0xB0, channel from track)
     = 0x7A: Program Change (status | 0xC0)
     = 0x7B: Channel Pressure (status | 0xD0)
     = 0x7C: Pitch Bend (status | 0xE0)
     = 0x7D: System Exclusive (0xF0 prefix)
   
   Also handles recording: stores incoming events with timestamps
   into the sequence buffer for note-on, controller, and sysex data.
   Active note tracking via IRAM 0xBE-0xFD (32 entries x 2 bytes).
   MIDI TX uses register bank 2 for buffer management. */

void sequence_playback_engine(void)

{
  bool bVar1;
  undefined1 uVar2;
  char *pcVar3;
  char *pcVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  char cVar9;
  byte bVar10;
  char cVar11;
  byte bVar12;
  byte bVar13;
  undefined2 uVar14;
  char *pcVar15;
  byte *pbVar16;
  byte *pbVar17;
  
  bVar12 = record_ptr_hi - (((current_track_idx < record_ptr_lo) << 7) >> 7);
  if (bVar12 <= active_track_mask) {
    return;
  }
  cVar11 = SP;
  SP = cVar11 + -1;
  cVar11 = SP;
  SP = cVar11 + -1;
  cVar11 = SP;
  SP = cVar11 + -1;
  cVar11 = SP;
  SP = cVar11 + -1;
  configure_tempo_timer(active_track_mask - bVar12);
  _d_7 = 0;
  ET0 = 1;
  send_midi_timing_clock(0xfc);
  lcd_clear_line();
LAB_CODE_025f:
  if (_f_2 == '\0') {
    display_track_mode_screen();
    uVar14 = 0x3c8;
  }
  else {
    display_song_mode_screen();
    uVar14 = 0x4b7;
  }
  display_ptr_lo = (undefined1)uVar14;
  display_ptr_hi = (undefined1)((ushort)uVar14 >> 8);
  IO_STATUS_LATCH = IO_STATUS_LATCH | 0x89;
  _d_1 = '\0';
LAB_CODE_0280:
  do {
    scan_keyboard();
    lcd_long_delay();
    lcd_long_delay();
    lcd_long_delay();
    if (IO_TRANSPORT_STATE == '\0') {
      tick_counter = '\0';
    }
    RS1 = 1;
    RS0 = 1;
    process_midi_input();
    RS0 = 0;
    RS1 = 0;
    process_midi_realtime_msgs();
    if (_f_3 != '\0') {
      _d_1 = '\0';
      _f_5 = '\0';
      if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) {
        display_ptr_lo = 0x3b;
        display_ptr_hi = 0x16;
        IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
      }
      else {
        start_recording_new_sequence();
      }
      setup_recording_state();
      _f_6 = '\0';
      track_mute_mask = 0;
      if (_c_3 == '\0') goto LAB_CODE_0fa0;
      start_track_playback();
      goto LAB_CODE_0fa0;
    }
    clear_track_event_buffers();
    if ((_8_4 == '\x01') || (_0_4 != '\0')) {
      if (IO_TRANSPORT_STATE == '\x01') {
        tick_counter = '\0';
      }
LAB_CODE_02e1:
      _d_1 = '\0';
      _f_5 = '\0';
      if (_f_2 != '\x01') {
        if (_6_7 == '\0') {
          if ((IO_STATUS_LATCH & 8) == 0) {
            start_recording_new_sequence();
            goto LAB_CODE_0f51;
          }
        }
        else {
          continue_recording_existing();
        }
      }
      display_ptr_lo = 0x3b;
      display_ptr_hi = 0x16;
      IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
LAB_CODE_0f51:
      do {
        while( true ) {
          _f_4 = 0;
          send_midi_timing_clock(0xfa);
          if (_c_3 == '\0') {
            if (_f_2 != '\0') {
              cEXTMEM05cd = '\0';
              init_song_playback();
            }
            update_display_full();
LAB_CODE_0f76:
            track_mute_mask = 0;
          }
          else {
            start_track_playback();
          }
          TF0 = 1;
          _f_6 = '\0';
          if (_c_3 != '\0') break;
LAB_CODE_0fa0:
          if ((_f_2 != '\0') && (cEXTMEM05ce == -1)) {
            _d_7 = 0;
            stop_all_playing_notes();
            _e_1 = 0;
            goto LAB_CODE_025f;
          }
          cEXTMEM04ed = cEXTMEM04ca;
          _e_1 = 0;
          if (_f_5 != '\x01') {
            update_position_display();
          }
          _c_7 = '\0';
          IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfe;
          _d_7 = 1;
          _0_4 = '\0';
          _0_5 = '\0';
          _8_4 = '\0';
          cEXTMEM04ec = '0';
          IO_IDLE_COUNTER = '\0';
LAB_CODE_1076:
          while( true ) {
            cEXTMEM04ec = cEXTMEM04ec + -1;
            if (cEXTMEM04ec == '\0') {
              cEXTMEM04ec = '0';
              scan_keyboard();
              check_transport_buttons();
              check_data_transfer_state();
              if ((_0_7 != '\0') && (cEXTMEM04cb == cEXTMEM04ca)) {
                stop_track_playback();
              }
            }
            RS1 = 1;
            RS0 = 1;
            process_midi_input();
            RS0 = 0;
            RS1 = 0;
            if (_0_4 != '\0') break;
            if ((_8_4 == '\x01') || (_0_5 != '\0')) {
LAB_CODE_10c0:
              _d_7 = 0;
              configure_tempo_timer();
              stop_all_playing_notes();
              send_midi_stop_msg();
              _e_1 = 0;
              send_midi_song_position();
              if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) goto LAB_CODE_025f;
              IO_STATUS_LATCH = IO_STATUS_LATCH | 0x81;
              handle_auto_continue_record();
              goto LAB_CODE_0280;
            }
            if (tick_counter == '\0') {
              IO_IDLE_COUNTER = IO_IDLE_COUNTER + '\x01';
              if ((((IO_IDLE_COUNTER == '\0') &&
                   (IO_TIMEOUT_COUNTER = IO_TIMEOUT_COUNTER + '\x01', IO_TIMEOUT_COUNTER == '\x14'))
                  && (IO_TRANSPORT_STATE == '\x02')) && (IO_CLICK_ENABLE != '\0'))
              goto LAB_CODE_10c0;
              if (_c_3 == '\x01') {
                process_recording_step();
              }
              else {
                clear_track_event_buffers();
              }
            }
            else {
              tick_counter = tick_counter + -1;
              T0 = 1;
              IO_IDLE_COUNTER = '\0';
              IO_TIMEOUT_COUNTER = '\0';
              bVar1 = 0xfe < midi_clock_lo;
              midi_clock_lo = midi_clock_lo + 1;
              midi_clock_hi = midi_clock_hi - ((bVar1 << 7) >> 7);
              tick_subdivider = tick_subdivider - 1;
              bVar12 = tick_subdivider;
              if (tick_subdivider == 0) {
                tick_subdivider = 0x60;
LAB_CODE_1146:
                if ((bVar12 & 3) == 0) {
                  send_midi_timing_clock(0xf8);
                }
LAB_CODE_11e7:
                click_countdown = click_countdown + -1;
                if (click_countdown == '\0') {
                  if (tick_subdivider == 0x60) {
                    cEXTMEM05d5 = cEXTMEM04d8;
                  }
                  cVar11 = cEXTMEM04d6;
                  if (_c_3 != '\x01') {
                    cVar11 = cEXTMEM04d7;
                  }
                  click_countdown = cEXTMEM05d5;
                  if (cVar11 != '\0') {
                    bVar12 = T1;
                    T1 = bVar12 ^ 1;
                    bVar12 = T1;
                    T1 = bVar12 ^ 1;
                  }
                }
                if (_c_3 != '\0') {
                  if (_f_6 == '\0') {
                    process_recording_realtime();
                  }
                  else {
                    _f_6 = '\0';
                    process_recording_step();
                  }
                  goto LAB_CODE_122e;
                }
LAB_CODE_122b:
                clear_track_event_buffers();
LAB_CODE_122e:
                current_track_idx = 0;
                track_bit_rotate = 1;
                pcVar3 = (char *)0x5d;
LAB_CODE_1236:
                active_track_mask = ~track_mute_mask & bEXTMEM04ce;
                do {
                  _d_0 = (active_track_mask & track_bit_rotate) != 0;
                  _d_1 = (track_mute_mask & track_bit_rotate) != 0;
                  pbVar16 = (byte *)CONCAT11(4,current_track_idx * '\x02' + -0x10);
                  bVar12 = *pbVar16;
                  bVar10 = bVar12 + 1;
                  *pbVar16 = bVar10;
                  pcVar15 = (char *)CONCAT11(4,current_track_idx * '\x02' + -0xf);
                  *pcVar15 = *pcVar15 - (((0xfe < bVar12) << 7) >> 7);
                  cVar11 = *(char *)CONCAT11(4,current_track_idx - 0x25) + -1;
                  pcVar4 = pcVar3 + '\x01';
                  pbVar16 = (byte *)CONCAT11(*pcVar4,*pcVar3);
                  if (*pcVar4 != '\0') {
                    bVar12 = *pbVar16 & 0x7f;
                    pbVar17 = pbVar16 + 2;
                    if ((pbVar16[1] == BANK0_R1) && (*pbVar17 == BANK0_R3)) {
                      do {
                        bVar7 = pbVar17[1];
                        bVar6 = pbVar17[2];
                        if ((-1 < (char)bVar7) && ((char)bVar6 < '\0')) {
                          if ((_d_1 == '\x01') || (*pcVar4 = '\0', uVar2 = BANK0_R0, _f_2 == '\0'))
                          goto LAB_CODE_1371;
                          handle_song_part_change(current_track_idx);
                          pcVar3 = pcVar4 + -1;
                          BANK0_R0 = uVar2;
                          goto LAB_CODE_1236;
                        }
                        bVar8 = bVar6;
                        if ((cVar11 != -1) && (bVar8 = BANK0_R7, bVar7 == 0xfd)) {
                          bVar8 = bVar6;
                        }
                        bVar6 = pbVar17[3];
                        bVar13 = pbVar17[4];
                        pbVar17 = pbVar17 + 5;
                        if ((char)bVar7 < '\0') {
                          bVar7 = bVar7 & 0x7f;
                          if (BANK0_R2 == 0x7a) {
                            if (_c_7 != '\0') {
                              midi_tx_end_sysex();
                            }
                            if (_d_0 == '\x01') {
                              RS1 = 1;
                              saved_P2_page = 0;
                              P2 = 0;
                              ES = 0;
                              if (_c_4 != '\x01') {
                                TI = 1;
                                _c_4 = '\x01';
                              }
                              *(byte *)(ushort)bVar10 = BANK0_R3 | 0xc0;
                              bVar12 = bVar10 + 1;
                              if (bVar10 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              *(byte *)(ushort)bVar12 = bVar7;
                              bVar10 = bVar12 + 1;
                              if (bVar12 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              ES = 1;
                              RS1 = 0;
                            }
                          }
                          else if (BANK0_R2 < 0x7a) {
                            if (_c_7 != '\0') {
                              midi_tx_end_sysex();
                            }
                            if (_d_0 == '\x01') {
                              RS1 = 1;
                              saved_P2_page = 0;
                              P2 = 0;
                              ES = 0;
                              if (_c_4 != '\x01') {
                                TI = 1;
                                _c_4 = '\x01';
                              }
                              *(byte *)(ushort)bVar10 = BANK0_R3 | 0xb0;
                              bVar12 = bVar10 + 1;
                              if (bVar10 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              *(byte *)(ushort)bVar12 = BANK0_R2;
                              bVar6 = bVar12 + 1;
                              if (bVar12 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              *(byte *)(ushort)bVar6 = bVar7;
                              bVar10 = bVar6 + 1;
                              if (bVar6 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              ES = 1;
                              RS1 = 0;
                            }
                          }
                          else if (BANK0_R2 == 0x7b) {
                            if (_c_7 != '\0') {
                              midi_tx_end_sysex();
                            }
                            if (_d_0 == '\x01') {
                              RS1 = 1;
                              saved_P2_page = 0;
                              P2 = 0;
                              ES = 0;
                              if (_c_4 != '\x01') {
                                TI = 1;
                                _c_4 = '\x01';
                              }
                              *(byte *)(ushort)bVar10 = BANK0_R3 | 0xd0;
                              bVar12 = bVar10 + 1;
                              if (bVar10 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              *(byte *)(ushort)bVar12 = bVar7;
                              bVar10 = bVar12 + 1;
                              if (bVar12 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              ES = 1;
                              RS1 = 0;
                            }
                          }
                          else if (BANK0_R2 == 0x7c) {
                            if (_c_7 != '\0') {
                              midi_tx_end_sysex();
                            }
                            if (_d_0 == '\x01') {
                              RS1 = 1;
                              saved_P2_page = 0;
                              P2 = 0;
                              ES = 0;
                              if (_c_4 != '\x01') {
                                TI = 1;
                                _c_4 = '\x01';
                              }
                              *(byte *)(ushort)bVar10 = BANK0_R3 | 0xe0;
                              bVar12 = bVar10 + 1;
                              if (bVar10 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              *(undefined1 *)(ushort)bVar12 = BANK0_R4;
                              bVar7 = bVar12 + 1;
                              if (bVar12 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              *(char *)(ushort)bVar7 = BANK0_R5;
                              bVar10 = bVar7 + 1;
                              if (bVar7 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              ES = 1;
                              RS1 = 0;
                            }
                          }
                          else if (BANK0_R2 == 0x7d) {
                            if (_d_0 == '\x01') {
                              RS1 = 1;
                              saved_P2_page = 0;
                              P2 = 0;
                              ES = 0;
                              if (_c_4 != '\x01') {
                                TI = 1;
                                _c_4 = '\x01';
                              }
                              if (_c_7 != '\x01') {
                                _c_7 = '\x01';
                                *(undefined1 *)(ushort)bVar10 = 0xf0;
                                bVar10 = bVar10 + 1;
                              }
                              *(byte *)(ushort)bVar10 = bVar7;
                              bVar12 = bVar10 + 1;
                              if (bVar10 + 2 == BANK2_R0) {
                                midi_tx_check_buffer_full();
                              }
                              bVar10 = bVar12;
                              if (-1 < (char)BANK0_R3) {
                                *(byte *)(ushort)bVar12 = BANK0_R3;
                                bVar7 = bVar12 + 1;
                                if (bVar12 + 2 == BANK2_R0) {
                                  midi_tx_check_buffer_full();
                                }
                                bVar10 = bVar7;
                                if (-1 < BANK0_R5) {
                                  *(char *)(ushort)bVar7 = BANK0_R5;
                                  bVar10 = bVar7 + 1;
                                  if (bVar7 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  ES = 1;
                                  RS1 = 0;
                                  goto LAB_CODE_1294;
                                }
                              }
                              midi_tx_flush_buffer();
                            }
                          }
                          else if (_c_7 != '\0') {
                            midi_tx_end_sysex();
                          }
                        }
                        else {
                          if (_c_7 != '\0') {
                            midi_tx_end_sysex();
                          }
                          if ((char)bVar8 < '\0') goto LAB_CODE_1371;
                          if (_d_1 != '\x01') {
                            saved_P2_page = 3;
                            P2 = 3;
                            cVar9 = '3';
                            bVar5 = 0;
                            do {
                              if (-1 < *(char *)(ushort)bVar5) {
                                *(byte *)(ushort)bVar5 =
                                     current_track_idx >> 4 | current_track_idx << 4 | 0x80 | bVar8;
                                *(byte *)(ushort)(bVar5 + 1) = bVar7;
                                *(byte *)(ushort)(bVar5 + 2) = bVar12;
                                *(byte *)(ushort)(bVar5 + 3) = bVar13;
                                bVar10 = bVar5 + 4;
                                *(byte *)(ushort)bVar10 = bVar6;
                                if (_d_0 == '\x01') {
                                  RS1 = 1;
                                  saved_P2_page = 0;
                                  P2 = 0;
                                  ES = 0;
                                  if (_c_4 != '\x01') {
                                    TI = 1;
                                    _c_4 = '\x01';
                                  }
                                  *(byte *)(ushort)bVar10 = BANK0_R3 | 0x90;
                                  bVar12 = bVar5 + 5;
                                  if (bVar5 + 6 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  *(byte *)(ushort)bVar12 = BANK0_R2;
                                  bVar6 = bVar12 + 1;
                                  if (bVar12 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  *(byte *)(ushort)bVar6 = bVar7;
                                  bVar10 = bVar6 + 1;
                                  if (bVar6 + 2 == BANK2_R0) {
                                    midi_tx_check_buffer_full();
                                  }
                                  ES = 1;
                                  RS1 = 0;
                                }
                                break;
                              }
                              bVar10 = bVar5 + 5;
                              cVar9 = cVar9 + -1;
                              bVar5 = bVar10;
                            } while (cVar9 != '\0');
                          }
                        }
LAB_CODE_1294:
                        if (solo_track_num == current_track_idx) {
                          _f_7 = 1;
                        }
                        bVar12 = *pbVar17;
                      } while (-1 < (char)bVar12);
                      *pcVar4 = (char)((ushort)pbVar17 >> 8);
                      pcVar4[-1] = (char)pbVar17;
                      if (_c_7 != '\0') {
                        midi_tx_end_sysex();
                      }
                    }
                  }
LAB_CODE_1371:
                  current_track_idx = current_track_idx + 1;
                  pcVar3 = pcVar4 + '\x01';
                  if ((byte *)pcVar3 == &current_track_idx) {
                    if (cEXTMEM05d6 != '\0') {
                      cEXTMEM05d6 = cEXTMEM05d6 + -1;
                      goto LAB_CODE_122e;
                    }
                    T0 = 0;
                    active_track_mask = active_track_mask | track_mute_mask;
                    P2 = 3;
                    bVar12 = 0;
                    cVar11 = '3';
                    goto LAB_CODE_1558;
                  }
                  track_bit_rotate = track_bit_rotate << 1 | track_bit_rotate >> 7;
                } while( true );
              }
              if (tick_subdivider != 1) goto LAB_CODE_1146;
              _e_0 = 1;
              bVar1 = 0xfe < measure_bcd_lo;
              measure_bcd_lo = decimal_adjust(measure_bcd_lo + 1);
              measure_bcd_hi = decimal_adjust(measure_bcd_hi - ((bVar1 << 7) >> 7));
              if ((measure_bcd_hi != total_measures_hi) || (measure_bcd_lo != total_measures_lo))
              goto LAB_CODE_11e7;
              if (_f_2 != '\0') {
                pcVar15 = (char *)0x5cd;
                cEXTMEM05cd = cEXTMEM05cd + '\x01';
                get_song_step_data();
                cEXTMEM00ce = *pcVar15;
                if (cEXTMEM00ce < '\0') {
                  pcVar15 = (char *)0x5cd;
                  cEXTMEM05cd = '\0';
                  get_song_step_data();
                  cEXTMEM00ce = *pcVar15;
                  if (_f_5 != '\x01') {
                    update_position_display();
                  }
                  if (_d_5 == '\0') {
                    set_default_tempo_values();
                    update_display_full();
                    goto LAB_CODE_11cd;
                  }
                  handle_song_completion();
                }
                else {
                  handle_song_completion();
                  if (_f_5 != '\x01') {
                    update_position_display();
                  }
                }
                goto LAB_CODE_122b;
              }
              F0 = _d_3 & 1;
              configure_tempo_timer();
              handle_sequence_boundary();
              if ((_d_0 != '\x01') && (_d_5 == '\0')) {
LAB_CODE_11cd:
                _d_7 = 0;
                stop_all_playing_notes();
                send_midi_stop_msg();
                _e_1 = 0;
                send_midi_song_position();
                goto LAB_CODE_025f;
              }
              track_mute_mask = 0;
              IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfe;
              _c_7 = '\0';
              T0 = 0;
              cVar11 = F0;
              if (cVar11 != '\0') {
                handle_loop_display();
              }
            }
          }
          configure_tempo_timer();
          send_midi_timing_clock(0xfc);
          handle_sequence_boundary();
        }
        process_playback_buttons();
        if (_0_4 == '\0') {
          if (_0_5 == '\0') {
            if (_c_1 != '\0') {
              _f_6 = '\x01';
            }
            goto LAB_CODE_0fa0;
          }
          _d_7 = 0;
          stop_all_playing_notes();
          _e_1 = 0;
          goto LAB_CODE_025f;
        }
        send_midi_timing_clock(0xfc);
      } while( true );
    }
    if (((_0_5 != '\0') && (_6_0 != '\x01')) && (_6_1 != '\x01')) {
      if (_c_3 == '\0') {
        _d_1 = '\0';
        _f_5 = '\0';
        if (IO_TRANSPORT_STATE == '\x01') {
          tick_counter = '\0';
        }
        if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) {
          display_ptr_lo = 0x3b;
          display_ptr_hi = 0x16;
          setup_sequence_data_ptrs();
          IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
        }
        else {
          start_recording_new_sequence();
          init_metronome_click();
        }
        setup_recording_state();
        goto LAB_CODE_0f76;
      }
      _c_3 = '\0';
      IO_STATUS_LATCH = IO_STATUS_LATCH | 2;
    }
    if (((tick_counter != '\0') && (IO_TRANSPORT_STATE == '\x02')) && (IO_CLICK_ENABLE != '\0'))
    goto LAB_CODE_02e1;
    check_transport_buttons();
    if (_3_0 != '\0') {
      _d_1 = '\0';
      handle_play_button();
    }
    if (_2_0 != '\0') {
      _d_1 = '\0';
      handle_record_button();
    }
    if (_5_0 != '\0') {
      _d_1 = '\0';
      handle_stop_continue();
    }
    if (_5_7 != '\0') {
      _d_1 = '\0';
      handle_copy_function();
    }
    if (_4_0 != '\0') {
      _d_1 = '\0';
      handle_delete_function();
    }
    if (_3_7 != '\0') {
      _d_1 = '\0';
      handle_midi_channel_filter();
    }
    if (_0_6 != '\0') {
      _d_1 = '\0';
      handle_tempo_edit_button();
    }
    if (_0_1 != '\0') {
      _d_1 = '\0';
      handle_track_select_button();
    }
    if (_0_0 != '\0') {
      _d_1 = '\0';
      handle_track_select_button();
    }
    display_tempo_info();
    check_data_transfer_state();
    display_status_message();
  } while( true );
LAB_CODE_1558:
  do {
    bVar10 = *(byte *)(ushort)bVar12;
    if ((char)bVar10 < '\0') {
      bVar7 = bVar12 + 3;
      cVar9 = *(char *)(ushort)bVar7;
      *(char *)(ushort)bVar7 = cVar9 + -1;
      if (cVar9 + -1 != '\0') goto LAB_CODE_155f;
      cVar9 = *(char *)(ushort)(bVar12 + 4);
      if (cVar9 == '\0') {
        bVar8 = bVar12 + 1;
        *(undefined1 *)(ushort)bVar12 = 0;
        cVar9 = ((bVar10 & 0x70) >> 4) + 1;
        bVar7 = 0x80;
        bVar6 = 0;
        do {
          bVar13 = bVar6 << 1 | bVar7 >> 7;
          bVar7 = bVar6 & 0x80;
          cVar9 = cVar9 + -1;
          bVar6 = bVar13;
        } while (cVar9 != '\0');
        if ((bVar13 & active_track_mask) != 0) {
          RS1 = 1;
          saved_P2_page = 0;
          P2 = 0;
          ES = 0;
          if (_c_4 != '\x01') {
            TI = 1;
            _c_4 = '\x01';
          }
          *(byte *)(ushort)bVar12 = BANK0_R3 | 0x80;
          if (bVar12 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full(*(undefined1 *)(ushort)(bVar12 + 2),bVar10 & 0xf);
          }
          *(byte *)(ushort)bVar8 = BANK0_R2;
          bVar10 = bVar8 + 1;
          if (bVar8 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full();
          }
          *(undefined1 *)(ushort)bVar10 = 0x40;
          bVar12 = bVar10 + 1;
          if (bVar10 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full();
          }
          ES = 1;
          RS1 = 0;
          P2 = 3;
        }
        goto LAB_CODE_155c;
      }
      *(char *)(ushort)(bVar12 + 4) = cVar9 + -1;
      bVar12 = bVar12 + 5;
    }
    else {
LAB_CODE_155c:
      bVar7 = bVar12 + 3;
LAB_CODE_155f:
      bVar12 = bVar7 + 2;
    }
    cVar11 = cVar11 + -1;
    saved_P2_page = 3;
  } while (cVar11 != '\0');
  goto LAB_CODE_1076;
}



/* ====================================================================== */
/* Function at 0x0B26: process_midi_input */
/* ====================================================================== */

/* Process incoming MIDI data from serial RX buffer.
   Called in main loop with register bank 2/3 context (RS1=1, RS0=1).
   Parses MIDI messages and dispatches to appropriate handlers. */

void process_midi_input(byte param_1,char param_2)

{
  bool bVar1;
  undefined1 *puVar2;
  char *pcVar3;
  char *pcVar4;
  byte bVar5;
  byte bVar6;
  char cVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  char cVar12;
  byte bVar13;
  undefined1 *puVar14;
  undefined2 uVar15;
  byte *pbVar16;
  char *pcVar17;
  byte *pbVar18;
  
code_c0x0b26:
  saved_P2_page = 1;
  P2 = 1;
  if (param_1 == BANK3_R1) {
    return;
  }
  bVar10 = *(byte *)(ushort)param_1;
  param_1 = param_1 + 1;
  if (-1 < (char)bVar10) {
                    /* WARNING: Could not recover jumptable at 0x0b3e. Too many branches */
                    /* WARNING: Treating indirect jump as call */
    (*(code *)CONCAT11(init_param_a,init_param_b))();
    return;
  }
  switch(bVar10 & 0x70) {
  case 0:
    _c_5 = 0;
    BANK3_R2 = BANK3_R2 & 0xf;
    DAT_INTMEM_7a = bVar10;
    do {
      do {
        do {
          func_0x0b22();
          DAT_INTMEM_79 = bVar10;
          func_0x0b22();
        } while (_e_3 == '\x01');
      } while ((-1 < (char)last_button_state) && (last_button_state != DAT_INTMEM_7a));
      if (_d_6 != '\0') {
        midi_tx_note_off(0x80);
      }
      cVar7 = cEXTMEM001f;
      saved_P2_page = 2;
      P2 = 2;
      RS1 = 0;
      bVar11 = cEXTMEM001f + 0x20;
      cEXTMEM001f = cEXTMEM001f + '\x02';
      *(byte *)(ushort)bVar11 = DAT_INTMEM_79;
      *(byte *)(ushort)(cVar7 + 0x21) = DAT_INTMEM_7a;
      RS1 = 1;
    } while( true );
  case 0x10:
    _c_5 = 0;
    BANK3_R2 = BANK3_R2 & 0xf;
    DAT_INTMEM_7a = bVar10;
    do {
      do {
        func_0x0b22();
        DAT_INTMEM_79 = bVar10;
        func_0x0b22();
      } while (_e_3 == '\x01');
      if (((char)last_button_state < '\0') || (last_button_state == DAT_INTMEM_7a)) {
        if (_d_6 != '\0') {
          midi_tx_note_off(0x90);
        }
        cVar7 = cEXTMEM001f;
        bVar11 = bEXTMEM0000;
        saved_P2_page = 2;
        P2 = 2;
        RS1 = 0;
        if (BANK3_R2 == 0) {
          bVar11 = cEXTMEM001f + 0x20;
          cEXTMEM001f = cEXTMEM001f + '\x02';
          *(byte *)(ushort)bVar11 = DAT_INTMEM_79;
          *(byte *)(ushort)(cVar7 + 0x21) = DAT_INTMEM_7a;
          RS1 = 1;
        }
        else {
          bVar8 = bEXTMEM0000 + 3;
          bVar9 = bEXTMEM0000 + 1;
          bEXTMEM0000 = bVar8;
          *(byte *)(ushort)bVar9 = DAT_INTMEM_79;
          *(byte *)(ushort)(bVar11 + 2) = BANK3_R2;
          *(byte *)(ushort)bVar8 = DAT_INTMEM_7a;
          RS1 = 1;
        }
      }
    } while( true );
  case 0x20:
    goto code_c0x0f35;
  case 0x30:
    _c_5 = 0;
    BANK3_R2 = BANK3_R2 & 0xf;
    DAT_INTMEM_7a = bVar10;
    do {
      do {
        do {
          func_0x0b22();
          DAT_INTMEM_79 = bVar10;
          func_0x0b22();
        } while (_e_6 == '\x01');
      } while ((-1 < (char)last_button_state) && (last_button_state != DAT_INTMEM_7a));
      if (_d_6 != '\0') {
        midi_tx_note_off(0xb0);
      }
      cVar7 = cEXTMEM0034;
      if ((DAT_INTMEM_79 != 0x7a) && ((DAT_INTMEM_79 < 0x7a) << 7 < '\0')) {
        saved_P2_page = 2;
        P2 = 2;
        RS1 = 0;
        bVar11 = cEXTMEM0034 + 0x35;
        cEXTMEM0034 = cEXTMEM0034 + '\x03';
        *(byte *)(ushort)bVar11 = DAT_INTMEM_79;
        *(byte *)(ushort)(cVar7 + 0x36) = BANK3_R2;
        *(byte *)(ushort)(cVar7 + 0x37) = DAT_INTMEM_7a;
        RS1 = 1;
      }
    } while( true );
  case 0x40:
    _c_5 = 0;
    BANK3_R2 = BANK3_R2 & 0xf;
    DAT_INTMEM_7a = bVar10;
    do {
      do {
        do {
          func_0x0b22();
        } while (_e_7 == '\x01');
      } while ((-1 < (char)last_button_state) && (last_button_state != DAT_INTMEM_7a));
      if (_d_6 != '\0') {
        func_0x0d42(0xc0);
      }
      cVar7 = cEXTMEM0034;
      saved_P2_page = 2;
      P2 = 2;
      RS1 = 0;
      bVar10 = cEXTMEM0034 + 0x35;
      cEXTMEM0034 = cEXTMEM0034 + '\x03';
      *(undefined1 *)(ushort)bVar10 = 0x7a;
      *(byte *)(ushort)(cVar7 + 0x36) = BANK3_R2;
      *(byte *)(ushort)(cVar7 + 0x37) = DAT_INTMEM_7a;
      RS1 = 1;
    } while( true );
  case 0x50:
    _c_5 = 0;
    BANK3_R2 = BANK3_R2 & 0xf;
    DAT_INTMEM_7a = bVar10;
    do {
      do {
        do {
          func_0x0b22();
        } while (_e_5 == '\x01');
      } while ((-1 < (char)last_button_state) && (last_button_state != DAT_INTMEM_7a));
      if (_d_6 != '\0') {
        func_0x0d42(0xd0);
      }
      cVar7 = cEXTMEM0034;
      saved_P2_page = 2;
      P2 = 2;
      RS1 = 0;
      bVar10 = cEXTMEM0034 + 0x35;
      cEXTMEM0034 = cEXTMEM0034 + '\x03';
      *(undefined1 *)(ushort)bVar10 = 0x7b;
      *(byte *)(ushort)(cVar7 + 0x36) = BANK3_R2;
      *(byte *)(ushort)(cVar7 + 0x37) = DAT_INTMEM_7a;
      RS1 = 1;
    } while( true );
  case 0x60:
    _c_5 = 0;
    BANK3_R2 = BANK3_R2 & 0xf;
    DAT_INTMEM_7a = bVar10;
    do {
      do {
        do {
          func_0x0b22();
        } while (_e_4 == '\x01');
        DAT_INTMEM_79 = bVar10;
        func_0x0b22();
      } while ((-1 < (char)last_button_state) && (last_button_state != DAT_INTMEM_7a));
      if (_d_6 != '\0') {
        midi_tx_note_off(0xe0);
      }
      cVar7 = cEXTMEM006b;
      saved_P2_page = 2;
      P2 = 2;
      RS1 = 0;
      bVar11 = cEXTMEM006b + 0x6c;
      cEXTMEM006b = cEXTMEM006b + '\x03';
      *(byte *)(ushort)bVar11 = DAT_INTMEM_79;
      *(byte *)(ushort)(cVar7 + 0x6d) = BANK3_R2;
      *(byte *)(ushort)(cVar7 + 0x6e) = DAT_INTMEM_7a;
      RS1 = 1;
    } while( true );
  }
  switch(bVar10 & 0xf) {
  case 0:
    _c_5 = 1;
    func_0x0b22();
    if (_f_0 != '\x01') {
      func_0x0e79();
    }
    if (bVar10 != 0) goto code_c0x0ddb;
    func_0x0b22();
    if (_f_0 != '\x01') {
      func_0x0e79();
    }
    if (bVar10 != 0) goto code_c0x0ddb;
    func_0x0b22();
    if (_f_0 != '\x01') {
      func_0x0e79();
    }
    if (bVar10 != 0xe) goto code_c0x0ddb;
    func_0x0b22();
    if (_f_0 != '\x01') {
      func_0x0e79();
    }
    if (bVar10 != 0) {
code_c0x0ddb:
      do {
        do {
          func_0x0b22();
        } while (_f_0 == '\x01');
        func_0x0e79();
      } while( true );
    }
    RS0 = 0;
    RS1 = 0;
    lcd_write_space(0x2ccb);
    RS0 = 1;
    RS1 = 1;
    pbVar16 = (byte *)0x400;
    saved_P2_page = 1;
    P2 = 1;
    while( true ) {
      do {
      } while (param_1 == BANK3_R1);
      bVar10 = *(byte *)(ushort)param_1;
      param_1 = param_1 + 1;
      if ((char)bVar10 < '\0') break;
      cVar7 = '\a';
      while( true ) {
        do {
        } while (param_1 == BANK3_R1);
        bVar11 = *(byte *)(ushort)param_1;
        param_1 = param_1 + 1;
        if ((char)bVar11 < '\0') goto RESET_vector;
        cVar12 = '\b' - cVar7;
        bVar11 = bVar11 << 1 | bVar11 >> 7;
        do {
          bVar8 = bVar11 << 1;
          bVar10 = bVar10 << 1 | bVar11 >> 7;
          cVar12 = cVar12 + -1;
          bVar11 = bVar8;
        } while (cVar12 != '\0');
        *pbVar16 = bVar10;
        pbVar16 = pbVar16 + 1;
        cVar7 = cVar7 + -1;
        if (cVar7 == '\0') break;
        bVar10 = 0;
        cVar12 = BANK3_R4;
        do {
          bVar10 = bVar10 << 1 | bVar8 >> 7;
          cVar12 = cVar12 + -1;
          bVar8 = bVar8 << 1;
        } while (cVar12 != '\0');
      }
    }
RESET_vector:
    do {
      SP = 0x2f;
      TMOD = 0x21;
      TCON = 0x51;
      IP = 1;
      SCON = 0x70;
      TH1 = 0xff;
      TL1 = 0xff;
      puVar2 = &BANK0_R2;
      do {
        *puVar2 = 0;
        puVar2 = puVar2 + '\x01';
        do {
          param_2 = param_2 + -1;
        } while (param_2 != '\0');
      } while (puVar2 != (undefined1 *)0x80);
      IO_LED_CONTROL = 1;
      puVar14 = (undefined1 *)0xff08;
      LCD_CMD_DATA = 0x38;
      lcd_long_delay();
      lcd_long_delay();
      lcd_long_delay();
      *puVar14 = 0x38;
      lcd_short_delay();
      *puVar14 = 6;
      lcd_short_delay();
      *puVar14 = 0xe;
      lcd_short_delay();
      *puVar14 = 1;
      lcd_long_delay();
      puVar14 = &IO_KEY_COLUMN_SEL;
      IO_KEY_COLUMN_SEL = 0xfe;
      lcd_short_delay();
      cVar7 = P1;
      if (cVar7 == -5) {
        *puVar14 = 0xfd;
        lcd_short_delay();
        cVar7 = P1;
        if (cVar7 != -1) goto LAB_CODE_0192;
        *puVar14 = 0xfb;
        lcd_short_delay();
        cVar7 = P1;
        if (cVar7 != '?') goto LAB_CODE_0192;
        *puVar14 = 0xf7;
        lcd_short_delay();
        cVar7 = P1;
        if (cVar7 != -1) goto LAB_CODE_0192;
        *puVar14 = 0xef;
        lcd_short_delay();
        cVar7 = P1;
        if (cVar7 != -1) goto LAB_CODE_0192;
        *puVar14 = 0xdf;
        lcd_short_delay();
        cVar7 = P1;
        if (cVar7 != -1) goto LAB_CODE_0192;
LAB_CODE_01b1:
        *(undefined1 *)ZEXT12(puVar2) = 0xb5;
        *(undefined1 *)ZEXT12(puVar2 + -1) = 0x27;
        init_sequencer_defaults();
        display_tempo_info();
LAB_CODE_01be:
        P2 = 4;
        uEXTMEM00e5 = 0x80;
        uEXTMEM00e6 = 0xdf;
        uEXTMEM00e7 = 0xff;
        uEXTMEM00e8 = 0;
        uEXTMEM00e9 = 0x80;
        uEXTMEM00ea = 0;
        uEXTMEM00eb = 0;
        RS1 = 1;
        RS0 = 1;
        RS0 = 0;
        RS1 = 0;
        P2 = 2;
        bEXTMEM0000 = 0;
        cEXTMEM001f = 0;
        cEXTMEM0034 = 0;
        cEXTMEM006b = 0;
        uEXTMEM00a2 = 0;
        init_param_a = 0xb;
        init_param_b = 0x26;
        tick_counter = '\0';
        _c_4 = '\0';
        _c_5 = 0;
        _c_6 = 0;
        bEXTMEM04ce = 0xff;
        _e_5 = 1;
        _f_0 = 1;
        last_button_state = 0xff;
        if (cEXTMEM04ca == 'd') {
          _f_2 = '\x01';
          init_song_playback();
          IO_STATUS_LATCH = 0xef;
        }
        else {
          load_sequence_from_storage(0);
          IO_STATUS_LATCH = 0xfb;
        }
        IO_TRANSPORT_STATE = '\0';
        IO_BEAT_DIVIDER = 1;
        IO_CLICK_ENABLE = '\x01';
        _f_1 = 1;
        lcd_print_string(0x2289);
        _c_0 = 0;
        scan_keyboard();
        _c_0 = _8_4 & 1;
        IE = 0x92;
        IE0 = 0;
        update_display_full();
LAB_CODE_025f:
        if (_f_2 == '\0') {
          display_track_mode_screen();
          uVar15 = 0x3c8;
        }
        else {
          display_song_mode_screen();
          uVar15 = 0x4b7;
        }
        display_ptr_lo = (undefined1)uVar15;
        display_ptr_hi = (undefined1)((ushort)uVar15 >> 8);
        IO_STATUS_LATCH = IO_STATUS_LATCH | 0x89;
        _d_1 = '\0';
LAB_CODE_0280:
        do {
          scan_keyboard();
          lcd_long_delay();
          lcd_long_delay();
          lcd_long_delay();
          if (IO_TRANSPORT_STATE == '\0') {
            tick_counter = '\0';
          }
          RS1 = 1;
          RS0 = 1;
          process_midi_input();
          RS0 = 0;
          RS1 = 0;
          process_midi_realtime_msgs();
          if (_f_3 != '\0') {
            _d_1 = '\0';
            _f_5 = '\0';
            if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) {
              display_ptr_lo = 0x3b;
              display_ptr_hi = 0x16;
              IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
            }
            else {
              start_recording_new_sequence();
            }
            setup_recording_state();
            _f_6 = '\0';
            track_mute_mask = 0;
            if (_c_3 == '\0') goto LAB_CODE_0fa0;
            start_track_playback();
            goto LAB_CODE_0fa0;
          }
          clear_track_event_buffers();
          if ((_8_4 == 1) || (_0_4 != '\0')) {
            if (IO_TRANSPORT_STATE == '\x01') {
              tick_counter = '\0';
            }
LAB_CODE_02e1:
            _d_1 = '\0';
            _f_5 = '\0';
            if (_f_2 != '\x01') {
              if (_6_7 == '\0') {
                if ((IO_STATUS_LATCH & 8) == 0) {
                  start_recording_new_sequence();
                  goto LAB_CODE_0f51;
                }
              }
              else {
                continue_recording_existing();
              }
            }
            display_ptr_lo = 0x3b;
            display_ptr_hi = 0x16;
            IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
LAB_CODE_0f51:
            do {
              while( true ) {
                _f_4 = 0;
                send_midi_timing_clock(0xfa);
                if (_c_3 == '\0') {
                  if (_f_2 != '\0') {
                    cEXTMEM05cd = '\0';
                    init_song_playback();
                  }
                  update_display_full();
LAB_CODE_0f76:
                  track_mute_mask = 0;
                }
                else {
                  start_track_playback();
                }
                TF0 = 1;
                _f_6 = '\0';
                if (_c_3 != '\0') break;
LAB_CODE_0fa0:
                if ((_f_2 != '\0') && (cEXTMEM05ce == -1)) {
                  _d_7 = '\0';
                  stop_all_playing_notes();
                  _e_1 = 0;
                  goto LAB_CODE_025f;
                }
                cEXTMEM04ed = cEXTMEM04ca;
                _e_1 = 0;
                if (_f_5 != '\x01') {
                  update_position_display();
                }
                _c_7 = '\0';
                IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfe;
                _d_7 = '\x01';
                _0_4 = '\0';
                _0_5 = '\0';
                _8_4 = 0;
                cEXTMEM04ec = '0';
                IO_IDLE_COUNTER = '\0';
LAB_CODE_1076:
                while( true ) {
                  cEXTMEM04ec = cEXTMEM04ec + -1;
                  if (cEXTMEM04ec == '\0') {
                    cEXTMEM04ec = '0';
                    scan_keyboard();
                    check_transport_buttons();
                    check_data_transfer_state();
                    if ((_0_7 != '\0') && (cEXTMEM04cb == cEXTMEM04ca)) {
                      stop_track_playback();
                    }
                  }
                  RS1 = 1;
                  RS0 = 1;
                  process_midi_input();
                  RS0 = 0;
                  RS1 = 0;
                  if (_0_4 != '\0') break;
                  if ((_8_4 == 1) || (_0_5 != '\0')) {
LAB_CODE_10c0:
                    _d_7 = '\0';
                    configure_tempo_timer();
                    stop_all_playing_notes();
                    send_midi_stop_msg();
                    _e_1 = 0;
                    send_midi_song_position();
                    if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) goto LAB_CODE_025f;
                    IO_STATUS_LATCH = IO_STATUS_LATCH | 0x81;
                    handle_auto_continue_record();
                    goto LAB_CODE_0280;
                  }
                  if (tick_counter == '\0') {
                    IO_IDLE_COUNTER = IO_IDLE_COUNTER + '\x01';
                    if ((((IO_IDLE_COUNTER == '\0') &&
                         (IO_TIMEOUT_COUNTER = IO_TIMEOUT_COUNTER + '\x01',
                         IO_TIMEOUT_COUNTER == '\x14')) && (IO_TRANSPORT_STATE == '\x02')) &&
                       (IO_CLICK_ENABLE != '\0')) goto LAB_CODE_10c0;
                    if (_c_3 == '\x01') {
                      process_recording_step();
                    }
                    else {
                      clear_track_event_buffers();
                    }
                  }
                  else {
                    tick_counter = tick_counter + -1;
                    T0 = 1;
                    IO_IDLE_COUNTER = '\0';
                    IO_TIMEOUT_COUNTER = '\0';
                    bVar1 = 0xfe < midi_clock_lo;
                    midi_clock_lo = midi_clock_lo + 1;
                    midi_clock_hi = midi_clock_hi - ((bVar1 << 7) >> 7);
                    tick_subdivider = tick_subdivider - 1;
                    bVar10 = tick_subdivider;
                    if (tick_subdivider == 0) {
                      tick_subdivider = 0x60;
LAB_CODE_1146:
                      if ((bVar10 & 3) == 0) {
                        send_midi_timing_clock(0xf8);
                      }
LAB_CODE_11e7:
                      click_countdown = click_countdown + -1;
                      if (click_countdown == '\0') {
                        if (tick_subdivider == 0x60) {
                          cEXTMEM05d5 = cEXTMEM04d8;
                        }
                        cVar7 = cEXTMEM04d6;
                        if (_c_3 != '\x01') {
                          cVar7 = cEXTMEM04d7;
                        }
                        click_countdown = cEXTMEM05d5;
                        if (cVar7 != '\0') {
                          bVar10 = T1;
                          T1 = bVar10 ^ 1;
                          bVar10 = T1;
                          T1 = bVar10 ^ 1;
                        }
                      }
                      if (_c_3 != '\0') {
                        if (_f_6 == '\0') {
                          process_recording_realtime();
                        }
                        else {
                          _f_6 = '\0';
                          process_recording_step();
                        }
                        goto LAB_CODE_122e;
                      }
LAB_CODE_122b:
                      clear_track_event_buffers();
LAB_CODE_122e:
                      current_track_idx = 0;
                      track_bit_rotate = 1;
                      pcVar3 = (char *)0x5d;
LAB_CODE_1236:
                      active_track_mask = ~track_mute_mask & bEXTMEM04ce;
                      do {
                        _d_0 = (active_track_mask & track_bit_rotate) != 0;
                        _d_1 = (track_mute_mask & track_bit_rotate) != 0;
                        pbVar16 = (byte *)CONCAT11(4,current_track_idx * '\x02' + -0x10);
                        bVar10 = *pbVar16;
                        bVar11 = bVar10 + 1;
                        *pbVar16 = bVar11;
                        pcVar17 = (char *)CONCAT11(4,current_track_idx * '\x02' + -0xf);
                        *pcVar17 = *pcVar17 - (((0xfe < bVar10) << 7) >> 7);
                        cVar7 = *(char *)CONCAT11(4,current_track_idx - 0x25) + -1;
                        pcVar4 = pcVar3 + '\x01';
                        pbVar16 = (byte *)CONCAT11(*pcVar4,*pcVar3);
                        if (*pcVar4 != '\0') {
                          bVar10 = *pbVar16 & 0x7f;
                          pbVar18 = pbVar16 + 2;
                          if ((pbVar16[1] == BANK0_R1) && (*pbVar18 == BANK0_R3)) {
                            do {
                              bVar8 = pbVar18[1];
                              bVar9 = pbVar18[2];
                              if ((-1 < (char)bVar8) && ((char)bVar9 < '\0')) {
                                if ((_d_1 == '\x01') ||
                                   (*pcVar4 = '\0', bVar10 = BANK0_R0, _f_2 == '\0'))
                                goto LAB_CODE_1371;
                                handle_song_part_change(current_track_idx);
                                pcVar3 = pcVar4 + -1;
                                BANK0_R0 = bVar10;
                                goto LAB_CODE_1236;
                              }
                              bVar6 = bVar9;
                              if ((cVar7 != -1) && (bVar6 = BANK0_R7, bVar8 == 0xfd)) {
                                bVar6 = bVar9;
                              }
                              bVar9 = pbVar18[3];
                              bVar13 = pbVar18[4];
                              pbVar18 = pbVar18 + 5;
                              if ((char)bVar8 < '\0') {
                                bVar8 = bVar8 & 0x7f;
                                if (BANK0_R2 == 0x7a) {
                                  if (_c_7 != '\0') {
                                    midi_tx_end_sysex();
                                  }
                                  if (_d_0 == '\x01') {
                                    RS1 = 1;
                                    saved_P2_page = 0;
                                    P2 = 0;
                                    ES = 0;
                                    if (_c_4 != '\x01') {
                                      TI = 1;
                                      _c_4 = '\x01';
                                    }
                                    *(byte *)(ushort)bVar11 = BANK0_R3 | 0xc0;
                                    bVar10 = bVar11 + 1;
                                    if (bVar11 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    *(byte *)(ushort)bVar10 = bVar8;
                                    bVar11 = bVar10 + 1;
                                    if (bVar10 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    ES = 1;
                                    RS1 = 0;
                                  }
                                }
                                else if (BANK0_R2 < 0x7a) {
                                  if (_c_7 != '\0') {
                                    midi_tx_end_sysex();
                                  }
                                  if (_d_0 == '\x01') {
                                    RS1 = 1;
                                    saved_P2_page = 0;
                                    P2 = 0;
                                    ES = 0;
                                    if (_c_4 != '\x01') {
                                      TI = 1;
                                      _c_4 = '\x01';
                                    }
                                    *(byte *)(ushort)bVar11 = BANK0_R3 | 0xb0;
                                    bVar10 = bVar11 + 1;
                                    if (bVar11 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    *(byte *)(ushort)bVar10 = BANK0_R2;
                                    bVar9 = bVar10 + 1;
                                    if (bVar10 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    *(byte *)(ushort)bVar9 = bVar8;
                                    bVar11 = bVar9 + 1;
                                    if (bVar9 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    ES = 1;
                                    RS1 = 0;
                                  }
                                }
                                else if (BANK0_R2 == 0x7b) {
                                  if (_c_7 != '\0') {
                                    midi_tx_end_sysex();
                                  }
                                  if (_d_0 == '\x01') {
                                    RS1 = 1;
                                    saved_P2_page = 0;
                                    P2 = 0;
                                    ES = 0;
                                    if (_c_4 != '\x01') {
                                      TI = 1;
                                      _c_4 = '\x01';
                                    }
                                    *(byte *)(ushort)bVar11 = BANK0_R3 | 0xd0;
                                    bVar10 = bVar11 + 1;
                                    if (bVar11 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    *(byte *)(ushort)bVar10 = bVar8;
                                    bVar11 = bVar10 + 1;
                                    if (bVar10 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    ES = 1;
                                    RS1 = 0;
                                  }
                                }
                                else if (BANK0_R2 == 0x7c) {
                                  if (_c_7 != '\0') {
                                    midi_tx_end_sysex();
                                  }
                                  if (_d_0 == '\x01') {
                                    RS1 = 1;
                                    saved_P2_page = 0;
                                    P2 = 0;
                                    ES = 0;
                                    if (_c_4 != '\x01') {
                                      TI = 1;
                                      _c_4 = '\x01';
                                    }
                                    *(byte *)(ushort)bVar11 = BANK0_R3 | 0xe0;
                                    bVar10 = bVar11 + 1;
                                    if (bVar11 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    *(undefined1 *)(ushort)bVar10 = BANK0_R4;
                                    bVar8 = bVar10 + 1;
                                    if (bVar10 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    *(char *)(ushort)bVar8 = BANK0_R5;
                                    bVar11 = bVar8 + 1;
                                    if (bVar8 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    ES = 1;
                                    RS1 = 0;
                                  }
                                }
                                else if (BANK0_R2 == 0x7d) {
                                  if (_d_0 == '\x01') {
                                    RS1 = 1;
                                    saved_P2_page = 0;
                                    P2 = 0;
                                    ES = 0;
                                    if (_c_4 != '\x01') {
                                      TI = 1;
                                      _c_4 = '\x01';
                                    }
                                    if (_c_7 != '\x01') {
                                      _c_7 = '\x01';
                                      *(undefined1 *)(ushort)bVar11 = 0xf0;
                                      bVar11 = bVar11 + 1;
                                    }
                                    *(byte *)(ushort)bVar11 = bVar8;
                                    bVar10 = bVar11 + 1;
                                    if (bVar11 + 2 == BANK2_R0) {
                                      midi_tx_check_buffer_full();
                                    }
                                    bVar11 = bVar10;
                                    if (-1 < (char)BANK0_R3) {
                                      *(byte *)(ushort)bVar10 = BANK0_R3;
                                      bVar8 = bVar10 + 1;
                                      if (bVar10 + 2 == BANK2_R0) {
                                        midi_tx_check_buffer_full();
                                      }
                                      bVar11 = bVar8;
                                      if (-1 < BANK0_R5) {
                                        *(char *)(ushort)bVar8 = BANK0_R5;
                                        bVar11 = bVar8 + 1;
                                        if (bVar8 + 2 == BANK2_R0) {
                                          midi_tx_check_buffer_full();
                                        }
                                        ES = 1;
                                        RS1 = 0;
                                        goto LAB_CODE_1294;
                                      }
                                    }
                                    midi_tx_flush_buffer();
                                  }
                                }
                                else if (_c_7 != '\0') {
                                  midi_tx_end_sysex();
                                }
                              }
                              else {
                                if (_c_7 != '\0') {
                                  midi_tx_end_sysex();
                                }
                                if ((char)bVar6 < '\0') goto LAB_CODE_1371;
                                if (_d_1 != '\x01') {
                                  saved_P2_page = 3;
                                  P2 = 3;
                                  cVar12 = '3';
                                  bVar5 = 0;
                                  do {
                                    if (-1 < *(char *)(ushort)bVar5) {
                                      *(byte *)(ushort)bVar5 =
                                           current_track_idx >> 4 | current_track_idx << 4 | 0x80 |
                                           bVar6;
                                      *(byte *)(ushort)(bVar5 + 1) = bVar8;
                                      *(byte *)(ushort)(bVar5 + 2) = bVar10;
                                      *(byte *)(ushort)(bVar5 + 3) = bVar13;
                                      bVar11 = bVar5 + 4;
                                      *(byte *)(ushort)bVar11 = bVar9;
                                      if (_d_0 == '\x01') {
                                        RS1 = 1;
                                        saved_P2_page = 0;
                                        P2 = 0;
                                        ES = 0;
                                        if (_c_4 != '\x01') {
                                          TI = 1;
                                          _c_4 = '\x01';
                                        }
                                        *(byte *)(ushort)bVar11 = BANK0_R3 | 0x90;
                                        bVar10 = bVar5 + 5;
                                        if (bVar5 + 6 == BANK2_R0) {
                                          midi_tx_check_buffer_full();
                                        }
                                        *(byte *)(ushort)bVar10 = BANK0_R2;
                                        bVar9 = bVar10 + 1;
                                        if (bVar10 + 2 == BANK2_R0) {
                                          midi_tx_check_buffer_full();
                                        }
                                        *(byte *)(ushort)bVar9 = bVar8;
                                        bVar11 = bVar9 + 1;
                                        if (bVar9 + 2 == BANK2_R0) {
                                          midi_tx_check_buffer_full();
                                        }
                                        ES = 1;
                                        RS1 = 0;
                                      }
                                      break;
                                    }
                                    bVar11 = bVar5 + 5;
                                    cVar12 = cVar12 + -1;
                                    bVar5 = bVar11;
                                  } while (cVar12 != '\0');
                                }
                              }
LAB_CODE_1294:
                              if (solo_track_num == current_track_idx) {
                                _f_7 = 1;
                              }
                              bVar10 = *pbVar18;
                            } while (-1 < (char)bVar10);
                            *pcVar4 = (char)((ushort)pbVar18 >> 8);
                            pcVar4[-1] = (char)pbVar18;
                            if (_c_7 != '\0') {
                              midi_tx_end_sysex();
                            }
                          }
                        }
LAB_CODE_1371:
                        current_track_idx = current_track_idx + 1;
                        pcVar3 = pcVar4 + '\x01';
                        if ((byte *)pcVar3 == &current_track_idx) {
                          if (cEXTMEM05d6 != '\0') {
                            cEXTMEM05d6 = cEXTMEM05d6 + -1;
                            goto LAB_CODE_122e;
                          }
                          T0 = 0;
                          active_track_mask = active_track_mask | track_mute_mask;
                          P2 = 3;
                          bVar10 = 0;
                          cVar7 = '3';
                          goto LAB_CODE_1558;
                        }
                        track_bit_rotate = track_bit_rotate << 1 | track_bit_rotate >> 7;
                      } while( true );
                    }
                    if (tick_subdivider != 1) goto LAB_CODE_1146;
                    _e_0 = 1;
                    bVar1 = 0xfe < measure_bcd_lo;
                    measure_bcd_lo = decimal_adjust(measure_bcd_lo + 1);
                    measure_bcd_hi = decimal_adjust(measure_bcd_hi - ((bVar1 << 7) >> 7));
                    if ((measure_bcd_hi != total_measures_hi) ||
                       (measure_bcd_lo != total_measures_lo)) goto LAB_CODE_11e7;
                    if (_f_2 != '\0') {
                      pcVar17 = (char *)0x5cd;
                      cEXTMEM05cd = cEXTMEM05cd + '\x01';
                      get_song_step_data();
                      cEXTMEM00ce = *pcVar17;
                      if (cEXTMEM00ce < '\0') {
                        pcVar17 = (char *)0x5cd;
                        cEXTMEM05cd = '\0';
                        get_song_step_data();
                        cEXTMEM00ce = *pcVar17;
                        if (_f_5 != '\x01') {
                          update_position_display();
                        }
                        if (_d_5 == '\0') {
                          set_default_tempo_values();
                          update_display_full();
                          goto LAB_CODE_11cd;
                        }
                        handle_song_completion();
                      }
                      else {
                        handle_song_completion();
                        if (_f_5 != '\x01') {
                          update_position_display();
                        }
                      }
                      goto LAB_CODE_122b;
                    }
                    F0 = _d_3 & 1;
                    configure_tempo_timer();
                    handle_sequence_boundary();
                    if ((_d_0 != '\x01') && (_d_5 == '\0')) {
LAB_CODE_11cd:
                      _d_7 = '\0';
                      stop_all_playing_notes();
                      send_midi_stop_msg();
                      _e_1 = 0;
                      send_midi_song_position();
                      goto LAB_CODE_025f;
                    }
                    track_mute_mask = 0;
                    IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfe;
                    _c_7 = '\0';
                    T0 = 0;
                    cVar7 = F0;
                    if (cVar7 != '\0') {
                      handle_loop_display();
                    }
                  }
                }
                configure_tempo_timer();
                send_midi_timing_clock(0xfc);
                handle_sequence_boundary();
              }
              process_playback_buttons();
              if (_0_4 == '\0') {
                if (_0_5 == '\0') {
                  if (_c_1 != '\0') {
                    _f_6 = '\x01';
                  }
                  goto LAB_CODE_0fa0;
                }
                _d_7 = '\0';
                stop_all_playing_notes();
                _e_1 = 0;
                goto LAB_CODE_025f;
              }
              send_midi_timing_clock(0xfc);
            } while( true );
          }
          if (((_0_5 != '\0') && (_6_0 != '\x01')) && (_6_1 != '\x01')) {
            if (_c_3 == '\0') {
              _d_1 = '\0';
              _f_5 = '\0';
              if (IO_TRANSPORT_STATE == '\x01') {
                tick_counter = '\0';
              }
              if ((_f_2 == '\x01') || ((IO_STATUS_LATCH & 8) != 0)) {
                display_ptr_lo = 0x3b;
                display_ptr_hi = 0x16;
                setup_sequence_data_ptrs();
                IO_STATUS_LATCH = IO_STATUS_LATCH | 8;
              }
              else {
                start_recording_new_sequence();
                init_metronome_click();
              }
              setup_recording_state();
              goto LAB_CODE_0f76;
            }
            _c_3 = '\0';
            IO_STATUS_LATCH = IO_STATUS_LATCH | 2;
          }
          if (((tick_counter != '\0') && (IO_TRANSPORT_STATE == '\x02')) &&
             (IO_CLICK_ENABLE != '\0')) goto LAB_CODE_02e1;
          check_transport_buttons();
          if (_3_0 != '\0') {
            _d_1 = '\0';
            handle_play_button();
          }
          if (_2_0 != '\0') {
            _d_1 = '\0';
            handle_record_button();
          }
          if (_5_0 != '\0') {
            _d_1 = '\0';
            handle_stop_continue();
          }
          if (_5_7 != '\0') {
            _d_1 = '\0';
            handle_copy_function();
          }
          if (_4_0 != '\0') {
            _d_1 = '\0';
            handle_delete_function();
          }
          if (_3_7 != '\0') {
            _d_1 = '\0';
            handle_midi_channel_filter();
          }
          if (_0_6 != '\0') {
            _d_1 = '\0';
            handle_tempo_edit_button();
          }
          if (_0_1 != '\0') {
            _d_1 = '\0';
            handle_track_select_button();
          }
          if (_0_0 != '\0') {
            _d_1 = '\0';
            handle_track_select_button();
          }
          display_tempo_info();
          check_data_transfer_state();
          display_status_message();
        } while( true );
      }
LAB_CODE_0192:
      *puVar14 = 0xdf;
      lcd_short_delay();
      cVar7 = P1;
      if (cVar7 != -0xd) {
        P2 = 2;
        puVar2 = (undefined1 *)0xff;
        if ((cEXTMEM00fe == '\'') && (cEXTMEM00ff == -0x4b)) goto LAB_CODE_01be;
        goto LAB_CODE_01b1;
      }
      IO_LED_DATA = 0xff;
      IO_STATUS_LATCH = 0xff;
      lcd_print_string(0x7c68);
      pcVar17 = (char *)0x0;
      cVar7 = '\0';
      do {
        *pcVar17 = cVar7;
        pcVar17 = pcVar17 + 1;
        cVar7 = cVar7 + '\x03';
      } while ((char)((ushort)pcVar17 >> 8) != -1);
      pcVar17 = (char *)0x0;
      cVar7 = '\0';
      do {
        cVar12 = *pcVar17;
        if (cVar12 != cVar7) {
          selftest_show_message(0x7c98);
          do {
                    /* WARNING: Do nothing block with infinite loop */
          } while( true );
        }
        pcVar17 = pcVar17 + 1;
        cVar7 = cVar12 + '\x03';
      } while ((char)((ushort)pcVar17 >> 8) != -1);
      lcd_print_string(0x7c88);
      selftest_show_message(0x7ca8);
      bVar10 = 0xfe;
      param_2 = '\x01';
      pbVar16 = (byte *)0x0;
      do {
        pbVar18 = pbVar16;
        bVar1 = CARRY1(*pbVar18,bVar10);
        bVar10 = *pbVar18 + bVar10;
        if (bVar1) {
          param_2 = param_2 + '\x01';
        }
        pbVar16 = pbVar18 + 1;
      } while (((char)pbVar16 != -2) || ((char)((ushort)pbVar16 >> 8) != '\x7f'));
      if ((*pbVar16 != BANK0_R1) || (pbVar18[2] != BANK0_R0)) {
        selftest_show_message(0x7cb8);
        do {
                    /* WARNING: Do nothing block with infinite loop */
        } while( true );
      }
      selftest_show_message(0x7cc8);
      selftest_pass_msg(0x7cd8);
      IO_LED_DATA = 0;
      IO_STATUS_LATCH = 0;
      selftest_delay_loop();
      selftest_delay_loop();
      selftest_delay_loop();
      IO_LED_DATA = 0xff;
      puVar14 = &IO_STATUS_LATCH;
      selftest_ram_rw(0xfe,7);
      *puVar14 = 0xff;
      puVar14 = &IO_LED_DATA;
      selftest_ram_rw(0xfe,8);
      *puVar14 = 0xff;
      RI = 0;
      TI = 0;
      selftest_show_message(0x7d18);
      cVar7 = RI;
      if (cVar7 == '\x01') {
LAB_CODE_7bfc:
        selftest_show_message(0x7d28);
        do {
                    /* WARNING: Do nothing block with infinite loop */
        } while( true );
      }
      SBUF = 0;
      selftest_delay_loop();
      RI = 0;
      SBUF = 0x55;
      selftest_delay_loop();
      cVar7 = RI;
      if ((cVar7 == '\0') || (cVar7 = SBUF, cVar7 != 'U')) goto LAB_CODE_7bfc;
      selftest_show_message(0x7d38);
      IE0 = 0;
      T0 = 0;
      selftest_show_message(0x7ce8);
      cVar7 = IE0;
      if (cVar7 == '\x01') {
LAB_CODE_7c22:
        selftest_show_message(0x7cf8);
        do {
                    /* WARNING: Do nothing block with infinite loop */
        } while( true );
      }
      T0 = 1;
      selftest_delay_loop();
      cVar7 = IE0;
      if (cVar7 == '\0') goto LAB_CODE_7c22;
      selftest_show_message(0x7d08);
    } while( true );
  case 1:
    break;
  case 2:
    _c_5 = 0;
    do {
      func_0x0b22();
      DAT_INTMEM_79 = bVar10;
      func_0x0b22();
      if (_d_6 != '\0') {
        func_0x0d7b(0xf2);
      }
      saved_P2_page = 2;
      P2 = 2;
      RS1 = 0;
      uEXTMEM00bb = 1;
      bEXTMEM00bc = DAT_INTMEM_79;
      bEXTMEM00bd = BANK3_R2;
      RS1 = 1;
    } while( true );
  case 3:
    break;
  case 4:
    break;
  case 5:
    break;
  case 6:
    break;
  case 7:
    break;
  case 8:
    if (_f_1 != '\0') {
      tick_counter = tick_counter + '\x04';
    }
    goto code_c0x0b26;
  case 9:
    goto code_c0x0b26;
  case 10:
    if (_d_7 != '\x01') {
      if (_f_1 == '\x01') {
        tick_counter = '\0';
        _0_4 = '\x01';
        ET0 = 0;
      }
      else if ((IO_TRANSPORT_STATE == '\x01') && (IO_CLICK_ENABLE == '\x01')) {
        tick_counter = '\0';
        _0_4 = '\x01';
      }
    }
    goto code_c0x0b26;
  case 0xb:
    if (_d_7 != '\x01') {
      if (_f_1 == '\x01') {
        tick_counter = '\0';
        _f_3 = '\x01';
        ET0 = 0;
      }
      else if ((IO_TRANSPORT_STATE == '\x01') && (IO_CLICK_ENABLE == '\x01')) {
        tick_counter = '\0';
        _f_3 = '\x01';
      }
    }
    goto code_c0x0b26;
  case 0xc:
    if ((_d_7 != '\0') &&
       ((_f_1 == '\x01' || ((IO_TRANSPORT_STATE == '\x01' && (IO_CLICK_ENABLE == '\x01')))))) {
      _0_5 = '\x01';
    }
    goto code_c0x0b26;
  case 0xd:
    goto code_c0x0b26;
  case 0xe:
    goto code_c0x0b26;
  case 0xf:
    goto code_c0x0dd9;
  }
code_c0x0f35:
  _c_5 = 0;
  init_param_a = 0xb;
  init_param_b = 0x26;
  goto code_c0x0b26;
code_c0x0dd9:
  goto code_c0x0b26;
LAB_CODE_1558:
  do {
    bVar11 = *(byte *)(ushort)bVar10;
    if ((char)bVar11 < '\0') {
      bVar8 = bVar10 + 3;
      cVar12 = *(char *)(ushort)bVar8;
      *(char *)(ushort)bVar8 = cVar12 + -1;
      if (cVar12 + -1 != '\0') goto LAB_CODE_155f;
      cVar12 = *(char *)(ushort)(bVar10 + 4);
      if (cVar12 == '\0') {
        bVar6 = bVar10 + 1;
        *(undefined1 *)(ushort)bVar10 = 0;
        cVar12 = ((bVar11 & 0x70) >> 4) + 1;
        bVar8 = 0x80;
        bVar9 = 0;
        do {
          bVar13 = bVar9 << 1 | bVar8 >> 7;
          bVar8 = bVar9 & 0x80;
          cVar12 = cVar12 + -1;
          bVar9 = bVar13;
        } while (cVar12 != '\0');
        if ((bVar13 & active_track_mask) != 0) {
          RS1 = 1;
          saved_P2_page = 0;
          P2 = 0;
          ES = 0;
          if (_c_4 != '\x01') {
            TI = 1;
            _c_4 = '\x01';
          }
          *(byte *)(ushort)bVar10 = BANK0_R3 | 0x80;
          if (bVar10 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full(*(undefined1 *)(ushort)(bVar10 + 2),bVar11 & 0xf);
          }
          *(byte *)(ushort)bVar6 = BANK0_R2;
          bVar11 = bVar6 + 1;
          if (bVar6 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full();
          }
          *(undefined1 *)(ushort)bVar11 = 0x40;
          bVar10 = bVar11 + 1;
          if (bVar11 + 2 == BANK2_R0) {
            midi_tx_check_buffer_full();
          }
          ES = 1;
          RS1 = 0;
          P2 = 3;
        }
        goto LAB_CODE_155c;
      }
      *(char *)(ushort)(bVar10 + 4) = cVar12 + -1;
      bVar10 = bVar10 + 5;
    }
    else {
LAB_CODE_155c:
      bVar8 = bVar10 + 3;
LAB_CODE_155f:
      bVar10 = bVar8 + 2;
    }
    cVar7 = cVar7 + -1;
    saved_P2_page = 3;
  } while (cVar7 != '\0');
  goto LAB_CODE_1076;
}



/* ====================================================================== */
/* Function at 0x0CFD: midi_tx_note_off */
/* ====================================================================== */
/* Decompilation failed: 
Low-level Error: Free varnode has multiple descendants */

/* ====================================================================== */
/* Function at 0x0FB4: stop_all_playing_notes */
/* ====================================================================== */

/* Stop all currently sounding notes.
   Sends MIDI note-off for all tracked active notes. */

void stop_all_playing_notes(byte param_1)

{
  if (IO_TRANSPORT_STATE == '\x02') {
    ET0 = 0;
    EX0 = 1;
    tick_counter = 0;
  }
  else {
    ET0 = 1;
    EX0 = 0;
  }
  if (IO_BEAT_DIVIDER == '\0') {
    return;
  }
  RS1 = 1;
  saved_P2_page = 0;
  P2 = 0;
  ES = 0;
  if (_c_4 != '\x01') {
    TI = 1;
    _c_4 = '\x01';
  }
  *(undefined1 *)(ushort)param_1 = 0xfc;
  ES = 1;
  RS1 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x0FE2: update_position_display */
/* ====================================================================== */

/* Update measure/beat position display on LCD during playback.
   Shows current position within sequence. */

void update_position_display(void)

{
  byte bVar1;
  undefined2 uVar2;
  
  if (_f_2 == '\x01') {
    lcd_write_byte_hex(0x22e9);
    bVar1 = (cEXTMEM05cd + 1U) % 100;
    cEXTMEM05ed = (cEXTMEM05cd + 1U) / 100 + 0x30;
    cEXTMEM05ee = bVar1 / 10 + 0x30;
    cEXTMEM05ef = bVar1 % 10 + 0x30;
    cEXTMEM05f5 = bEXTMEM05ce / 10 + 0x30;
    cEXTMEM05f6 = bEXTMEM05ce % 10 + 0x30;
    lcd_write_string_inline(5,uEXTMEM05ca);
    format_bcd_number();
    return;
  }
  if (cEXTMEM04ed != cEXTMEM04ca) {
    lcd_write_byte_hex(0x2349);
    lcd_write_string_inline(5,cEXTMEM04ca);
    lcd_write_string_inline(0xe,cEXTMEM04ed);
    format_bcd_number();
    return;
  }
  if (_c_3 == '\0') {
    uVar2 = 0x2329;
  }
  else {
    uVar2 = 0x23a9;
  }
  lcd_write_byte_hex(uVar2);
  lcd_write_string_inline(0xe,cEXTMEM04ca);
  format_bcd_number();
  return;
}



/* ====================================================================== */
/* Function at 0x0FFE: handle_loop_display */
/* ====================================================================== */

/* Update display for loop/repeat mode. */

void handle_loop_display(void)

{
  lcd_write_byte_hex(0x2329);
  lcd_write_string_inline(0xe,uEXTMEM04ca);
  format_bcd_number();
  return;
}



/* ====================================================================== */
/* Function at 0x10E8: configure_tempo_timer */
/* ====================================================================== */

/* Configure Timer 0 reload values for current tempo.
   Computes TH0/TL0 reload from tempo BPM value.
   Stores reload values in IRAM 0x7E/0x7F for Timer0 ISR. */

void configure_tempo_timer(void)

{
  set_default_tempo_values();
  if (_d_3 != '\0') {
    if (_c_3 != '\0') {
      all_notes_off_cleanup();
    }
    advance_playback_position();
  }
  return;
}



/* ====================================================================== */
/* Function at 0x14C8: midi_tx_end_sysex */
/* ====================================================================== */

/* End current MIDI System Exclusive transmission.
   Sends F7 (End of SysEx) byte to TX buffer. */

void midi_tx_end_sysex(byte param_1)

{
  if (_d_0 != '\x01') {
    return;
  }
  RS1 = 1;
  saved_P2_page = 0;
  P2 = 0;
  ES = 0;
  if (_c_4 != '\x01') {
    TI = 1;
    _c_4 = '\x01';
  }
  *(undefined1 *)(ushort)param_1 = 0xf7;
  if (param_1 + 2 == BANK2_R0) {
    midi_tx_check_buffer_full();
  }
  ES = 1;
  RS1 = 0;
  _c_7 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x14DD: midi_tx_flush_buffer */
/* ====================================================================== */

/* Flush MIDI TX buffer: ensures all pending bytes are sent.
   Enables serial interrupt (ES=1), clears register bank (RS1=0). */

void midi_tx_flush_buffer(byte param_1)

{
  *(undefined1 *)(ushort)param_1 = 0xf7;
  if (param_1 + 2 == BANK2_R0) {
    midi_tx_check_buffer_full();
  }
  ES = 1;
  RS1 = 0;
  _c_7 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x14F0: midi_tx_check_buffer_full */
/* ====================================================================== */

/* Check if MIDI TX buffer is full.
   Compares write pointer against BANK2_R0 (buffer end).
   If full, enables ES and waits for space. Used by all MIDI TX functions. */

void midi_tx_check_buffer_full(void)

{
  char cVar1;
  char cVar2;
  
  ES = 1;
  cVar1 = '\0';
  cVar2 = '\x04';
  do {
    do {
      cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
    cVar2 = cVar2 + -1;
  } while (cVar2 != '\0');
  ES = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x15D7: handle_sequence_boundary */
/* ====================================================================== */

/* Handle reaching a sequence boundary (end of part/loop point).
   Decides whether to loop, advance to next part, or stop. */

void handle_sequence_boundary(void)

{
  _d_0 = 0;
  if ((_f_2 != '\x01') && (cEXTMEM04ca != cEXTMEM04ed)) {
    _d_0 = 1;
    cEXTMEM04ca = cEXTMEM04ed;
    if (_f_5 != '\x01') {
      _e_1 = 0;
      update_position_display();
      _e_0 = 1;
    }
  }
  update_display_full();
  return;
}



/* ====================================================================== */
/* Function at 0x15FF: send_midi_stop_msg */
/* ====================================================================== */

/* Send MIDI Stop (0xFC) real-time message.
   Called when playback stops. */

void send_midi_stop_msg(void)

{
  char cVar1;
  
  cVar1 = cEXTMEM04ca;
  if ((_f_2 != '\x01') && (cEXTMEM04ca != cEXTMEM04cb)) {
    cEXTMEM04ca = cEXTMEM04cb;
    cEXTMEM04cb = cVar1;
    init_playback_timing();
    _d_4 = 0;
    load_sequence_from_storage();
  }
  return;
}



/* ====================================================================== */
/* Function at 0x1709: format_bcd_number */
/* ====================================================================== */

/* Format a number as BCD for display.
   Converts binary value to BCD digits for LCD output. */

void format_bcd_number(void)

{
  undefined1 uVar1;
  
  uVar1 = 200;
  if (_f_2 != '\0') {
    uVar1 = 0xcd;
  }
  lcd_write_char(uVar1);
  format_number_2digit(measure_bcd_hi);
  format_number_2digit(measure_bcd_lo >> 4);
  format_number_2digit(measure_bcd_lo & 0xf);
  if (_f_2 != '\x01') {
    uVar1 = 0x8e;
    if (_e_1 != '\0') {
      uVar1 = 0x8f;
    }
    lcd_write_char(uVar1);
    _e_0 = 0;
  }
  return;
}



/* ====================================================================== */
/* Function at 0x1756: set_default_tempo_values */
/* ====================================================================== */

/* Set default tempo timer reload values. */

void set_default_tempo_values(void)

{
  byte bVar1;
  undefined1 uVar2;
  byte bVar3;
  byte bVar4;
  char cVar5;
  
  active_track_mask = bEXTMEM04ce;
  P2 = 3;
  bVar3 = 0;
  cVar5 = '3';
  do {
    bVar1 = *(byte *)(ushort)bVar3;
    if ((char)bVar1 < '\0') {
      bVar4 = bVar3 + 2;
      uVar2 = *(undefined1 *)(ushort)bVar4;
      if ((*(byte *)((ushort)((bVar1 & 0x70) >> 4) + 0x1855) & active_track_mask) != 0) {
        RS1 = 1;
        saved_P2_page = 0;
        P2 = 0;
        ES = 0;
        if (_c_4 != '\x01') {
          TI = 1;
          _c_4 = '\x01';
        }
        *(byte *)(ushort)bVar4 = BANK0_R3 | 0x80;
        bVar4 = bVar3 + 3;
        if (bVar3 + 4 == BANK2_R0) {
          midi_tx_check_buffer_full(uVar2,bVar1 & 0xf);
        }
        *(undefined1 *)(ushort)bVar4 = BANK0_R2;
        bVar3 = bVar4 + 1;
        if (bVar4 + 2 == BANK2_R0) {
          midi_tx_check_buffer_full();
        }
        *(undefined1 *)(ushort)bVar3 = 0x40;
        bVar4 = bVar3 + 1;
        if (bVar3 + 2 == BANK2_R0) {
          midi_tx_check_buffer_full();
        }
        ES = 1;
        RS1 = 0;
        P2 = 3;
      }
    }
    else {
      bVar4 = bVar3 + 2;
    }
    saved_P2_page = 3;
    bVar3 = bVar4 + 3;
    cVar5 = cVar5 + -1;
  } while (cVar5 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x175A: update_part_metadata */
/* ====================================================================== */

/* Update part metadata (length, track count, etc.).
   Called after recording or editing operations. */

void update_part_metadata(byte param_1)

{
  byte bVar1;
  undefined1 uVar2;
  byte bVar3;
  byte bVar4;
  char cVar5;
  
  P2 = 3;
  bVar3 = 0;
  cVar5 = '3';
  active_track_mask = param_1;
  do {
    bVar1 = *(byte *)(ushort)bVar3;
    if ((char)bVar1 < '\0') {
      bVar4 = bVar3 + 2;
      uVar2 = *(undefined1 *)(ushort)bVar4;
      if ((*(byte *)((ushort)((bVar1 & 0x70) >> 4) + 0x1855) & active_track_mask) != 0) {
        RS1 = 1;
        saved_P2_page = 0;
        P2 = 0;
        ES = 0;
        if (_c_4 != '\x01') {
          TI = 1;
          _c_4 = '\x01';
        }
        *(byte *)(ushort)bVar4 = BANK0_R3 | 0x80;
        bVar4 = bVar3 + 3;
        if (bVar3 + 4 == BANK2_R0) {
          midi_tx_check_buffer_full(uVar2,bVar1 & 0xf);
        }
        *(undefined1 *)(ushort)bVar4 = BANK0_R2;
        bVar3 = bVar4 + 1;
        if (bVar4 + 2 == BANK2_R0) {
          midi_tx_check_buffer_full();
        }
        *(undefined1 *)(ushort)bVar3 = 0x40;
        bVar4 = bVar3 + 1;
        if (bVar3 + 2 == BANK2_R0) {
          midi_tx_check_buffer_full();
        }
        ES = 1;
        RS1 = 0;
        P2 = 3;
      }
    }
    else {
      bVar4 = bVar3 + 2;
    }
    saved_P2_page = 3;
    bVar3 = bVar4 + 3;
    cVar5 = cVar5 + -1;
  } while (cVar5 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x17CA: setup_sequence_data_ptrs */
/* ====================================================================== */

/* Set up DPTR and data pointers for current sequence part.
   Configures XDATA addresses for sequence read/write. */

void setup_sequence_data_ptrs(void)

{
  byte bVar1;
  undefined1 uVar2;
  byte bVar3;
  byte bVar4;
  char cVar5;
  undefined1 uVar6;
  
  active_track_mask = bEXTMEM04ce;
  P2 = 3;
  bVar3 = 0;
  cVar5 = '3';
  do {
    bVar1 = *(byte *)(ushort)bVar3;
    if ((char)bVar1 < '\0') {
      uVar6 = *(undefined1 *)(ushort)(bVar3 + 1);
      bVar4 = bVar3 + 2;
      uVar2 = *(undefined1 *)(ushort)bVar4;
      if ((*(byte *)((ushort)((bVar1 & 0x70) >> 4) + 0x1855) & active_track_mask) != 0) {
        RS1 = 1;
        saved_P2_page = 0;
        P2 = 0;
        ES = 0;
        if (_c_4 != '\x01') {
          TI = 1;
          _c_4 = '\x01';
        }
        *(byte *)(ushort)bVar4 = BANK0_R3 | 0x90;
        bVar4 = bVar3 + 3;
        if (bVar3 + 4 == BANK2_R0) {
          midi_tx_check_buffer_full(uVar2,bVar1 & 0xf);
        }
        *(undefined1 *)(ushort)bVar4 = BANK0_R2;
        bVar3 = bVar4 + 1;
        if (bVar4 + 2 == BANK2_R0) {
          midi_tx_check_buffer_full();
        }
        *(undefined1 *)(ushort)bVar3 = uVar6;
        bVar4 = bVar3 + 1;
        if (bVar3 + 2 == BANK2_R0) {
          midi_tx_check_buffer_full();
        }
        ES = 1;
        RS1 = 0;
        P2 = 3;
      }
    }
    else {
      bVar4 = bVar3 + 2;
    }
    saved_P2_page = 3;
    bVar3 = bVar4 + 3;
    cVar5 = cVar5 + -1;
  } while (cVar5 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x17CE: init_sequence_part_data */
/* ====================================================================== */

/* Initialize sequence part data structures.
   Sets up header, track pointers, and default values for a part. */

void init_sequence_part_data(byte param_1)

{
  byte bVar1;
  undefined1 uVar2;
  byte bVar3;
  byte bVar4;
  char cVar5;
  undefined1 uVar6;
  
  P2 = 3;
  bVar3 = 0;
  cVar5 = '3';
  active_track_mask = param_1;
  do {
    bVar1 = *(byte *)(ushort)bVar3;
    if ((char)bVar1 < '\0') {
      uVar6 = *(undefined1 *)(ushort)(bVar3 + 1);
      bVar4 = bVar3 + 2;
      uVar2 = *(undefined1 *)(ushort)bVar4;
      if ((*(byte *)((ushort)((bVar1 & 0x70) >> 4) + 0x1855) & active_track_mask) != 0) {
        RS1 = 1;
        saved_P2_page = 0;
        P2 = 0;
        ES = 0;
        if (_c_4 != '\x01') {
          TI = 1;
          _c_4 = '\x01';
        }
        *(byte *)(ushort)bVar4 = BANK0_R3 | 0x90;
        bVar4 = bVar3 + 3;
        if (bVar3 + 4 == BANK2_R0) {
          midi_tx_check_buffer_full(uVar2,bVar1 & 0xf);
        }
        *(undefined1 *)(ushort)bVar4 = BANK0_R2;
        bVar3 = bVar4 + 1;
        if (bVar4 + 2 == BANK2_R0) {
          midi_tx_check_buffer_full();
        }
        *(undefined1 *)(ushort)bVar3 = uVar6;
        bVar4 = bVar3 + 1;
        if (bVar3 + 2 == BANK2_R0) {
          midi_tx_check_buffer_full();
        }
        ES = 1;
        RS1 = 0;
        P2 = 3;
      }
    }
    else {
      bVar4 = bVar3 + 2;
    }
    saved_P2_page = 3;
    bVar3 = bVar4 + 3;
    cVar5 = cVar5 + -1;
  } while (cVar5 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x1841: song_mode_helper */
/* ====================================================================== */

/* Song mode data initialization helper. */

void song_mode_helper(void)

{
  byte bVar1;
  char cVar2;
  
  saved_P2_page = 3;
  P2 = 3;
  bVar1 = 0;
  cVar2 = '3';
  do {
    *(undefined1 *)(ushort)bVar1 = 0;
    bVar1 = bVar1 + 5;
    cVar2 = cVar2 + -1;
  } while (cVar2 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x185D: send_midi_song_position */
/* ====================================================================== */

/* Send MIDI Song Position Pointer message.
   Transmits current sequence position for external sync. */

void send_midi_song_position(byte param_1)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  
  cVar3 = -0x50;
  RS1 = 1;
  saved_P2_page = 0;
  P2 = 0;
  ES = 0;
  if (_c_4 != '\x01') {
    TI = 1;
    _c_4 = '\x01';
  }
  do {
    *(char *)(ushort)param_1 = cVar3;
    bVar1 = param_1 + 1;
    if (param_1 + 2 == BANK2_R0) {
      midi_tx_check_buffer_full();
    }
    *(undefined1 *)(ushort)bVar1 = 0x40;
    bVar2 = bVar1 + 1;
    if (bVar1 + 2 == BANK2_R0) {
      midi_tx_check_buffer_full();
    }
    *(undefined1 *)(ushort)bVar2 = 0;
    param_1 = bVar2 + 1;
    if (bVar2 + 2 == BANK2_R0) {
      midi_tx_check_buffer_full();
    }
    cVar3 = cVar3 + '\x01';
  } while (cVar3 != -0x40);
  ES = 1;
  RS1 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x18A1: init_playback_timing */
/* ====================================================================== */

/* Initialize playback timing parameters.
   Sets up tempo, time signature, and clock dividers. */

void init_playback_timing(void)

{
  bool bVar1;
  byte bVar2;
  char cVar3;
  char *pcVar4;
  undefined2 uVar5;
  
  saved_P2_page = 4;
  P2 = 4;
  current_track_idx = cEXTMEM00ca;
  if (*(char *)(ushort)(byte)(cEXTMEM00ca * '\x02') == '\0') {
    do {
                    /* WARNING: Do nothing block with infinite loop */
    } while( true );
  }
  uEXTMEM00cd = 0;
  update_display_full();
  sequence_data_operations();
  saved_P2_page = 4;
  P2 = 4;
  active_track_mask = cEXTMEM00cb;
  if (cEXTMEM00cb != current_track_idx) {
    bVar2 = current_track_idx * '\x02';
    pcVar4 = (char *)CONCAT11(*(char *)(ushort)bVar2 -
                              (((0xed < *(byte *)(ushort)(bVar2 + 1)) << 7) >> 7),
                              *(byte *)(ushort)(bVar2 + 1) + 0x12);
    if ((*pcVar4 == '\0') && (pcVar4 = pcVar4 + 1, *pcVar4 == '\0')) {
      *(undefined1 *)(ushort)bVar2 = 0;
      bEXTMEM00cf = (byte)pcVar4 - 0x13;
      cEXTMEM00d0 = (char)((ushort)pcVar4 >> 8) + ((((byte)pcVar4 < 0x13) << 7) >> 7);
      bVar1 = 0x9d < bEXTMEM00d3;
      bEXTMEM00d3 = bEXTMEM00d3 + 0x62;
      cEXTMEM00d4 = cEXTMEM00d4 - ((bVar1 << 7) >> 7);
    }
    compute_tempo_reload();
    cVar3 = cEXTMEM00d0;
    bVar2 = active_track_mask * '\x02';
    if (*(char *)(ushort)bVar2 == '\0') {
      *(char *)(ushort)bVar2 = cEXTMEM00d0;
      uVar5 = CONCAT11(cVar3,bEXTMEM00cf);
      *(byte *)(ushort)(bVar2 + 1) = bEXTMEM00cf;
      copy_code_to_xdata(uVar5);
      bVar1 = 0x9d < bEXTMEM00cf;
      bEXTMEM00cf = bEXTMEM00cf + 0x62;
      cEXTMEM00d0 = cEXTMEM00d0 - ((bVar1 << 7) >> 7);
      bVar1 = bEXTMEM00d3 < 0x62;
      bEXTMEM00d3 = bEXTMEM00d3 + 0x9e;
      cEXTMEM00d4 = cEXTMEM00d4 + ((bVar1 << 7) >> 7);
    }
    cEXTMEM00ca = active_track_mask;
    update_display_full();
    return;
  }
  return;
}



/* ====================================================================== */
/* Function at 0x1943: compute_tempo_reload */
/* ====================================================================== */

/* Compute Timer 0 reload values from tempo BPM.
   Converts BPM to timer period for 96 PPQN resolution. */

void compute_tempo_reload(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  char cVar5;
  char cVar6;
  byte bVar7;
  byte bVar8;
  short sVar9;
  byte *pbVar10;
  
  if (active_track_mask < current_track_idx) {
    bVar3 = (active_track_mask + 1) * '\x02';
    cVar6 = (current_track_idx + 1) - (active_track_mask + 1);
    do {
      if (*(char *)(ushort)bVar3 != '\0') {
        sVar9 = CONCAT11((cEXTMEM00d0 + (((bEXTMEM00cf == 0) << 7) >> 7)) -
                         (*(char *)(ushort)bVar3 -
                         (((bEXTMEM00cf - 1 < *(byte *)(ushort)(bVar3 + 1)) << 7) >> 7)),
                         (bEXTMEM00cf - 1) - *(byte *)(ushort)(bVar3 + 1)) + 1;
        track_bit_rotate = cVar6;
        track_mute_mask = bVar3;
        sequence_data_read(bEXTMEM00d1,cEXTMEM00d2);
        cVar6 = cEXTMEM00d4;
        bVar3 = bEXTMEM00d3;
        cVar5 = (char)((ushort)sVar9 >> 8);
        bVar4 = (byte)sVar9;
        bVar1 = bEXTMEM00cf < bVar4;
        bEXTMEM00cf = bEXTMEM00cf - bVar4;
        cEXTMEM00d0 = cEXTMEM00d0 - (cVar5 - ((bVar1 << 7) >> 7));
        bVar1 = bEXTMEM00d1 < bVar4;
        bEXTMEM00d1 = bEXTMEM00d1 - bVar4;
        cEXTMEM00d2 = cEXTMEM00d2 - (cVar5 - ((bVar1 << 7) >> 7));
        bVar4 = track_mute_mask;
        cVar5 = track_bit_rotate;
        do {
          if (*(char *)(ushort)bVar4 != '\0') {
            bVar2 = *(byte *)(ushort)(bVar4 + 1);
            *(byte *)(ushort)(bVar4 + 1) = bVar2 + bVar3;
            *(char *)(ushort)bVar4 =
                 *(char *)(ushort)bVar4 + (cVar6 - ((CARRY1(bVar2,bVar3) << 7) >> 7));
          }
          bVar4 = bVar4 + 2;
          cVar5 = cVar5 + -1;
        } while (cVar5 != '\0');
        return;
      }
      bVar3 = bVar3 + 2;
      cVar6 = cVar6 + -1;
    } while (cVar6 != '\0');
  }
  else {
    bVar3 = active_track_mask * '\x02';
    cVar6 = active_track_mask - current_track_idx;
    do {
      if (*(char *)(ushort)bVar3 != '\0') {
        bVar2 = *(byte *)(ushort)(bVar3 + 1);
        pbVar10 = (byte *)CONCAT11(*(char *)(ushort)bVar3,bVar2);
        bVar4 = *pbVar10;
        bVar7 = bVar4 + bVar2;
        bVar8 = bVar7 - (bEXTMEM00d1 + 1);
        cVar5 = (pbVar10[1] + (*(char *)(ushort)bVar3 - ((CARRY1(bVar4,bVar2) << 7) >> 7))) -
                ((cEXTMEM00d2 - (((0xfe < bEXTMEM00d1) << 7) >> 7)) -
                (((bVar7 < bEXTMEM00d1 + 1) << 7) >> 7));
        track_bit_rotate = cVar6;
        track_mute_mask = bVar3;
        sequence_data_seek(bEXTMEM00cf,cEXTMEM00d0);
        cVar6 = cEXTMEM00d4;
        bVar3 = bEXTMEM00d3;
        bVar1 = CARRY1(bEXTMEM00cf,bVar8);
        bEXTMEM00cf = bEXTMEM00cf + bVar8;
        cEXTMEM00d0 = cEXTMEM00d0 + (cVar5 - ((bVar1 << 7) >> 7));
        bVar1 = CARRY1(bEXTMEM00d1,bVar8);
        bEXTMEM00d1 = bEXTMEM00d1 + bVar8;
        cEXTMEM00d2 = cEXTMEM00d2 + (cVar5 - ((bVar1 << 7) >> 7));
        bVar4 = track_mute_mask;
        cVar5 = track_bit_rotate;
        do {
          if (*(char *)(ushort)bVar4 != '\0') {
            bVar2 = *(byte *)(ushort)(bVar4 + 1);
            *(byte *)(ushort)(bVar4 + 1) = bVar2 - bVar3;
            *(char *)(ushort)bVar4 =
                 *(char *)(ushort)bVar4 - (cVar6 - (((bVar2 < bVar3) << 7) >> 7));
          }
          bVar4 = bVar4 - 2;
          cVar5 = cVar5 + -1;
        } while (cVar5 != '\0');
        return;
      }
      bVar3 = bVar3 - 2;
      cVar6 = cVar6 + -1;
    } while (cVar6 != '\0');
  }
  return;
}



/* ====================================================================== */
/* Function at 0x1A3B: sequence_data_seek */
/* ====================================================================== */

/* Seek to position in sequence data.
   Advances data pointer to target timestamp. */

void sequence_data_seek(undefined1 param_1,undefined1 param_2,undefined1 param_3,undefined1 param_4,
                       char param_5,char param_6)

{
  undefined1 uVar1;
  undefined1 *puVar2;
  undefined1 *puVar3;
  
  puVar2 = (undefined1 *)CONCAT11(param_2,param_1);
  puVar3 = (undefined1 *)CONCAT11(param_4,param_3);
  if (param_5 != '\0') {
    param_6 = param_6 + '\x01';
    puVar2 = (undefined1 *)CONCAT11(param_2,param_1);
    puVar3 = (undefined1 *)CONCAT11(param_4,param_3);
  }
  do {
    do {
      uVar1 = *puVar2;
      puVar2 = puVar2 + 1;
      *puVar3 = uVar1;
      puVar3 = puVar3 + 1;
      param_5 = param_5 + -1;
    } while (param_5 != '\0');
    param_6 = param_6 + -1;
  } while (param_6 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x1A60: sequence_data_read */
/* ====================================================================== */

/* Read next event from sequence data. */

void sequence_data_read(char param_1,char param_2,char param_3,char param_4,char param_5,
                       char param_6)

{
  bool bVar1;
  undefined1 *puVar2;
  
  if (param_5 != '\0') {
    param_6 = param_6 + '\x01';
  }
  do {
    do {
      puVar2 = (undefined1 *)CONCAT11(param_2,param_1);
      bVar1 = param_1 == '\0';
      param_1 = param_1 + -1;
      param_2 = param_2 + ((bVar1 << 7) >> 7);
      *(undefined1 *)CONCAT11(param_4,param_3) = *puVar2;
      bVar1 = param_3 == '\0';
      param_3 = param_3 + -1;
      param_4 = param_4 + ((bVar1 << 7) >> 7);
      param_5 = param_5 + -1;
    } while (param_5 != '\0');
    param_6 = param_6 + -1;
  } while (param_6 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x1A95: sequence_data_operations */
/* ====================================================================== */

/* Sequence data read/write operations.
   Manages the sequence data buffer in XDATA. */

void sequence_data_operations(byte param_1,char param_2)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  char cVar4;
  byte bVar5;
  char cVar6;
  byte *pbVar7;
  
  update_display_full();
  saved_P2_page = 4;
  P2 = 4;
  current_track_idx = cEXTMEM00ca;
  seq_start_ptr_lo = bEXTMEM00cc;
  if (bEXTMEM00cc == 0) {
    seq_start_ptr_lo = 1;
  }
  bVar3 = bEXTMEM00cd;
  if (bEXTMEM00cd == 0) {
    bVar3 = 1;
  }
  if (bVar3 != seq_start_ptr_lo) {
    seq_start_ptr_hi = bVar3;
    if (bVar3 < seq_start_ptr_lo) {
      cVar6 = (seq_start_ptr_lo - 2) * '\x02';
      BANK0_R2 = *(undefined1 *)(cVar6 + ']');
      BANK0_R3 = *(undefined1 *)(cVar6 + '^');
      if (bVar3 == 1) {
        cVar6 = *(char *)(ushort)(byte)(cEXTMEM00ca * '\x02');
        bVar2 = *(byte *)(ushort)(cEXTMEM00ca * '\x02' + 1);
        pbVar7 = (byte *)CONCAT11(cVar6,bVar2);
        bVar3 = *pbVar7;
        bVar5 = bVar3 + bVar2;
        cVar6 = pbVar7[1] + (cVar6 - ((CARRY1(bVar3,bVar2) << 7) >> 7));
        bVar3 = bVar5 - param_1;
      }
      else {
        cVar6 = (bVar3 - 2) * '\x02';
        bVar5 = *(byte *)(cVar6 + ']');
        bVar3 = bVar5 - param_1;
        cVar6 = *(char *)(cVar6 + '^');
      }
      cVar6 = cVar6 - (param_2 - (((bVar5 < param_1) << 7) >> 7));
      sequence_data_seek(bEXTMEM00cf,cEXTMEM00d0);
      cVar4 = cEXTMEM00d4;
      bVar5 = bEXTMEM00d3;
      bVar1 = CARRY1(bEXTMEM00cf,bVar3);
      bEXTMEM00cf = bEXTMEM00cf + bVar3;
      cEXTMEM00d0 = cEXTMEM00d0 + (cVar6 - ((bVar1 << 7) >> 7));
      bVar1 = CARRY1(bEXTMEM00d1,bVar3);
      bEXTMEM00d1 = bEXTMEM00d1 + bVar3;
      cEXTMEM00d2 = cEXTMEM00d2 + (cVar6 - ((bVar1 << 7) >> 7));
      pbVar7 = (byte *)CONCAT11(*(undefined1 *)(ushort)(byte)(current_track_idx * '\x02'),
                                *(undefined1 *)(ushort)(current_track_idx * '\x02' + 1));
      if (seq_start_ptr_hi == 1) {
        bVar1 = *pbVar7 < bEXTMEM00d3;
        *pbVar7 = *pbVar7 - bEXTMEM00d3;
        pbVar7[1] = pbVar7[1] - (cVar4 - ((bVar1 << 7) >> 7));
        pbVar7 = pbVar7 + 2;
        cVar6 = '\t';
      }
      else {
        cVar6 = '\n';
      }
      bVar3 = (cVar6 - seq_start_ptr_lo) * '\x02';
      pbVar7 = (byte *)CONCAT11((char)((ushort)pbVar7 >> 8) -
                                ((CARRY1(bVar3,(byte)pbVar7) << 7) >> 7),bVar3 + (byte)pbVar7);
      cVar6 = seq_start_ptr_lo - seq_start_ptr_hi;
      do {
        bVar3 = *pbVar7;
        *pbVar7 = bVar3 - bVar5;
        pbVar7[1] = pbVar7[1] - (cVar4 - (((bVar3 < bVar5) << 7) >> 7));
        pbVar7 = pbVar7 + 2;
        cVar6 = cVar6 + -1;
      } while (cVar6 != '\0');
    }
    else {
      cVar6 = (bVar3 - 2) * '\x02';
      bVar3 = *(byte *)(cVar6 + ']');
      bVar5 = bEXTMEM00cf - bVar3;
      cVar4 = cEXTMEM00d0 - (*(char *)(cVar6 + '^') - (((bEXTMEM00cf < bVar3) << 7) >> 7));
      sequence_data_read(bEXTMEM00cf - 1,cEXTMEM00d0 + (((bEXTMEM00cf == 0) << 7) >> 7),bEXTMEM00d1,
                         cEXTMEM00d2);
      cVar6 = cEXTMEM00d4;
      bVar3 = bEXTMEM00d3;
      bVar1 = bEXTMEM00cf < bVar5;
      bEXTMEM00cf = bEXTMEM00cf - bVar5;
      cEXTMEM00d0 = cEXTMEM00d0 - (cVar4 - ((bVar1 << 7) >> 7));
      bVar1 = bEXTMEM00d1 < bVar5;
      bEXTMEM00d1 = bEXTMEM00d1 - bVar5;
      cEXTMEM00d2 = cEXTMEM00d2 - (cVar4 - ((bVar1 << 7) >> 7));
      pbVar7 = (byte *)CONCAT11(*(undefined1 *)(ushort)(byte)(current_track_idx * '\x02'),
                                *(undefined1 *)(ushort)(current_track_idx * '\x02' + 1));
      if (seq_start_ptr_lo == 1) {
        bVar1 = CARRY1(*pbVar7,bEXTMEM00d3);
        *pbVar7 = *pbVar7 + bEXTMEM00d3;
        pbVar7[1] = pbVar7[1] + (cVar6 - ((bVar1 << 7) >> 7));
        pbVar7 = pbVar7 + 2;
        cVar4 = '\t';
      }
      else {
        cVar4 = '\n';
      }
      bVar5 = (cVar4 - seq_start_ptr_hi) * '\x02';
      pbVar7 = (byte *)CONCAT11((char)((ushort)pbVar7 >> 8) -
                                ((CARRY1(bVar5,(byte)pbVar7) << 7) >> 7),bVar5 + (byte)pbVar7);
      cVar4 = seq_start_ptr_hi - seq_start_ptr_lo;
      do {
        bVar5 = *pbVar7;
        *pbVar7 = bVar5 + bVar3;
        pbVar7[1] = pbVar7[1] + (cVar6 - ((CARRY1(bVar5,bVar3) << 7) >> 7));
        pbVar7 = pbVar7 + 2;
        cVar4 = cVar4 + -1;
      } while (cVar4 != '\0');
    }
  }
  bEXTMEM00cc = bEXTMEM00cd;
  update_display_full();
  record_ptr_lo = uEXTMEM04cf;
  record_ptr_hi = uEXTMEM04d0;
  if (cEXTMEM04cc == '\0') {
    BANK2_R2 = -1;
  }
  else {
    BANK2_R2 = *(char *)CONCAT11(4,cEXTMEM04cc + -0x26) + -1;
  }
  return;
}



/* ====================================================================== */
/* Function at 0x1C0D: update_display_full */
/* ====================================================================== */

/* Full display update: refreshes all LCD content.
   Called after mode changes, sequence loads, and transport state changes.
   Multiple callers across init, playback, and button handlers. */

void update_display_full(void)

{
  char cVar1;
  byte *pbVar2;
  byte bVar3;
  undefined1 *puVar4;
  char *pcVar5;
  char cVar6;
  byte *pbVar7;
  char *pcVar8;
  
  saved_P2_page = 4;
  P2 = 4;
  uEXTMEM00ef = 0;
  if (_f_2 == '\0') {
    uEXTMEM05d6 = 0;
    cVar6 = cEXTMEM00ca;
  }
  else {
    uEXTMEM05d6 = uEXTMEM05d7;
    cVar6 = cEXTMEM05ce;
    if (cEXTMEM05ce < '\0') {
      cVar6 = 'd';
    }
  }
  cVar1 = *(char *)(ushort)(byte)(cVar6 * '\x02');
  if (cVar1 == '\0') {
    uEXTMEM00ef = 1;
    puVar4 = (undefined1 *)0x5d;
    cVar6 = '\b';
    do {
      *puVar4 = 0xe5;
      puVar4['\x01'] = 4;
      puVar4 = puVar4 + '\x02';
      cVar6 = cVar6 + -1;
    } while (cVar6 != '\0');
    total_measures_lo = 0x83;
    total_measures_hi = 6;
  }
  else {
    bVar3 = *(byte *)(ushort)(cVar6 * '\x02' + 1);
    pcVar5 = (char *)0x6b;
    cVar6 = '\b';
    pbVar2 = (byte *)(CONCAT11(cVar1,bVar3) + 2);
    do {
      pbVar7 = pbVar2;
      *pcVar5 = *pbVar7 + bVar3;
      pcVar5['\x01'] = pbVar7[1] + (cVar1 - ((CARRY1(*pbVar7,bVar3) << 7) >> 7));
      pcVar5 = pcVar5 + -2;
      cVar6 = cVar6 + -1;
      pbVar2 = pbVar7 + 2;
    } while (cVar6 != '\0');
    total_measures_lo = pbVar7[2];
    pbVar7 = pbVar7 + 3;
    if (total_measures_lo == 0) {
      total_measures_hi = *pbVar7;
      if (total_measures_hi == 0) {
        uEXTMEM00ef = 1;
        total_measures_lo = 0x83;
        total_measures_hi = 6;
      }
    }
    else {
      total_measures_hi = *pbVar7;
    }
    bVar3 = 0xe2;
    cVar6 = '\b';
    do {
      pbVar7 = pbVar7 + 1;
      *(byte *)(ushort)bVar3 = *pbVar7;
      bVar3 = bVar3 - 1;
      cVar6 = cVar6 + -1;
    } while (cVar6 != '\0');
  }
  click_countdown = 1;
  tick_subdivider = 1;
  measure_bcd_lo = 1;
  measure_bcd_hi = 0;
  bVar3 = 0xf0;
  if (_f_2 == '\0') {
    do {
      *(undefined1 *)(ushort)bVar3 = 0xff;
      bVar3 = bVar3 + 1;
    } while (bVar3 != 0);
  }
  else {
    pcVar8 = (char *)0x5d8;
    do {
      *(char *)(ushort)bVar3 = *pcVar8 + -1;
      pcVar8 = pcVar8 + 1;
      *(undefined1 *)(ushort)(bVar3 + 1) = 0xff;
      bVar3 = bVar3 + 2;
    } while (bVar3 != 0);
  }
  midi_clock_hi = 0xff;
  midi_clock_lo = 0xff;
  song_mode_helper();
  return;
}



/* ====================================================================== */
/* Function at 0x1CC7: handle_song_part_change */
/* ====================================================================== */

/* Handle transition between parts within a song.
   Loads next part's sequence data when current part ends. */

void handle_song_part_change(char *param_1,byte param_2)

{
  byte bVar1;
  char cVar2;
  char *pcVar3;
  char *pcVar4;
  byte bVar5;
  char cVar6;
  char *pcVar7;
  short sVar8;
  byte bVar10;
  byte *pbVar9;
  
  _d_0 = '\x01';
  if (((measure_bcd_lo == '\x01') && (measure_bcd_hi == '\0')) &&
     ((tick_subdivider == 1 || (0x30 < tick_subdivider)))) {
    _d_0 = '\0';
  }
  get_song_step_data(param_2 * '\x02' + ']');
  pcVar3 = BANK0_R2;
  saved_P2_page = 4;
  P2 = 4;
  while( true ) {
    cVar6 = *param_1;
    if (cVar6 < '\0') {
      if (_d_5 == '\0') {
        cVar6 = 'd';
      }
      else {
        pcVar7 = (char *)CONCAT11(5,(cEXTMEM05ca + '\x01') * '\x02');
        bVar5 = pcVar7[1];
        param_1 = (char *)CONCAT11(*pcVar7 - (((0xee < bVar5) << 7) >> 7),bVar5 + 0x11);
        cVar6 = *param_1;
      }
    }
    cVar2 = *(char *)(ushort)(byte)(cVar6 * '\x02');
    if (cVar2 == '\0') break;
    if (_d_0 == '\0') {
      bVar5 = *(byte *)(ushort)(cVar6 * '\x02' + 1);
      bEXTMEM04ce = bEXTMEM04ce & ~*(byte *)((ushort)param_2 + 0x1855) | param_1[1];
      IO_LED_DATA = ~bEXTMEM04ce;
      sVar8 = CONCAT11(cVar2,bVar5) + 2;
      bVar1 = ('\a' - param_2) * '\x02';
      bVar10 = (byte)sVar8;
      cVar6 = (char)((ushort)sVar8 >> 8);
      if (CARRY1(bVar1,bVar10)) {
        cVar6 = cVar6 + '\x01';
      }
      pbVar9 = (byte *)CONCAT11(cVar6,bVar1 + bVar10);
      bVar1 = *pbVar9;
      pcVar4 = (char *)((byte)BANK0_R2 & *(byte *)((ushort)param_2 + 0x1855));
      *BANK0_R2 = bVar1 + bVar5;
      BANK0_R2 = pcVar4;
      pbVar9 = pbVar9 + 1;
      pcVar3['\x01'] = *pbVar9 + (cVar2 - ((CARRY1(bVar1,bVar5) << 7) >> 7));
      cVar6 = (char)((ushort)pbVar9 >> 8);
      if (CARRY1(param_2 + 10,(byte)pbVar9)) {
        cVar6 = cVar6 + '\x01';
      }
      *(undefined1 *)(ushort)(param_2 - 0x25) =
           *(undefined1 *)CONCAT11(cVar6,param_2 + 10 + (byte)pbVar9);
LAB_CODE_1d79:
      *(undefined1 *)(ushort)(param_2 * '\x02' - 0x10) = 0xff;
      *(undefined1 *)(ushort)(param_2 * '\x02' - 0xf) = 0xff;
      update_part_metadata(*(undefined1 *)((ushort)param_2 + 0x1855));
      saved_P2_page = 3;
      P2 = 3;
      bVar5 = 0;
      cVar6 = '3';
      do {
        if (((char)*(byte *)(ushort)bVar5 < '\0') &&
           ((*(byte *)(ushort)bVar5 & 0x70) == (param_2 >> 4 | param_2 << 4))) {
          *(undefined1 *)(ushort)bVar5 = 0;
        }
        bVar5 = bVar5 + 5;
        cVar6 = cVar6 + -1;
      } while (cVar6 != '\0');
      return;
    }
    param_1 = param_1 + 2;
    _d_0 = '\0';
  }
  *BANK0_R2 = -0x1b;
  pcVar3['\x01'] = '\x04';
  goto LAB_CODE_1d79;
}



/* ====================================================================== */
/* Function at 0x1DB4: handle_song_completion */
/* ====================================================================== */

/* Handle song reaching its end.
   Decides whether to loop song or stop based on settings. */

void handle_song_completion(void)

{
  byte bVar1;
  char cVar2;
  char cVar3;
  char *pcVar4;
  
  _c_7 = 0;
  saved_P2_page = 4;
  P2 = 4;
  cVar2 = cEXTMEM05ce;
  if (cEXTMEM05ce < '\0') {
    cVar2 = 'd';
  }
  cVar3 = *(char *)(ushort)(byte)(cVar2 * '\x02');
  if (cVar3 == '\0') {
    total_measures_lo = -0x7d;
    total_measures_hi = '\x06';
  }
  else {
    bVar1 = *(byte *)(ushort)(cVar2 * '\x02' + 1);
    if (0xed < bVar1) {
      cVar3 = cVar3 + '\x01';
    }
    pcVar4 = (char *)CONCAT11(cVar3,bVar1 + 0x12);
    total_measures_lo = *pcVar4;
    pcVar4 = pcVar4 + 1;
    if (total_measures_lo == '\0') {
      total_measures_hi = *pcVar4;
      if (total_measures_hi == '\0') {
        total_measures_lo = -0x7d;
        total_measures_hi = '\x06';
      }
    }
    else {
      total_measures_hi = *pcVar4;
    }
  }
  click_countdown = 1;
  tick_subdivider = 1;
  measure_bcd_lo = 1;
  measure_bcd_hi = 0;
  midi_clock_hi = 0xff;
  midi_clock_lo = 0xff;
  return;
}



/* ====================================================================== */
/* Function at 0x1E08: copy_code_to_xdata */
/* ====================================================================== */

/* Copy data from CODE memory to XDATA.
   Takes DPTR as source address in code space.
   Used to initialize XDATA tables from ROM constants. */

void copy_code_to_xdata(undefined1 *param_1)

{
  byte bVar1;
  
  bVar1 = 8;
  do {
    *param_1 = *(undefined1 *)((ushort)bVar1 + 0x1e0c);
    param_1 = param_1 + 1;
    bVar1 = bVar1 + 1;
  } while (bVar1 != 0x6a);
  return;
}



/* ====================================================================== */
/* Function at 0x1E76: compute_position_delta */
/* ====================================================================== */

/* Compute delta between two sequence positions.
   16-bit subtraction for position arithmetic. */

void compute_position_delta(char param_1,char param_2)

{
  char cVar1;
  char cVar2;
  char cVar3;
  
  cVar1 = track_bit_rotate;
  cVar2 = track_mute_mask;
  cVar3 = cEXTMEM04d2;
  do {
    multiply_8bit(cVar3);
    param_1 = param_1 + -1;
    if (param_1 == '\0') {
      if (param_2 == '\0') {
        position_calc_helper();
        return;
      }
    }
    else if (param_1 == -1) {
      param_2 = param_2 + -1;
    }
    cVar3 = cVar1;
    if ((cVar1 == BANK0_R0) && (cVar3 = cVar2, cVar2 == BANK0_R1)) {
      cVar3 = position_calc_helper();
      cVar1 = track_bit_rotate;
      cVar2 = track_mute_mask;
    }
  } while( true );
}



/* ====================================================================== */
/* Function at 0x1EA8: position_calc_helper */
/* ====================================================================== */

/* Helper for position calculation. */

void position_calc_helper(void)

{
  char cVar1;
  char cVar2;
  
  cVar1 = current_track_idx;
  cVar2 = active_track_mask;
  do {
    do {
      multiply_8bit();
    } while (cVar1 != track_bit_rotate);
  } while (cVar2 != track_mute_mask);
  return;
}



/* ====================================================================== */
/* Function at 0x1EB8: multiply_8bit */
/* ====================================================================== */

/* 8-bit multiply helper for position/timing calculations. */

void multiply_8bit(undefined1 param_1,undefined1 param_2,undefined1 param_3,undefined1 param_4)

{
  *(undefined1 *)CONCAT11(param_4,param_3) = *(undefined1 *)CONCAT11(param_2,param_1);
  return;
}



/* ====================================================================== */
/* Function at 0x1ECD: display_tempo_info */
/* ====================================================================== */

/* Display tempo and time signature information on LCD.
   Called after init and during tempo changes. */

void display_tempo_info(void)

{
  char cVar1;
  byte bVar2;
  short sVar3;
  
  sVar3 = 0x1ef1;
  bVar2 = bEXTMEM04da * '\x02';
  if (CARRY1(bEXTMEM04da,bEXTMEM04da)) {
    sVar3 = 0x1ff1;
  }
  cVar1 = ET0;
  if (cVar1 != '\0') {
    ET0 = 0;
    timer0_reload_hi = *(undefined1 *)(sVar3 + (ushort)bVar2);
    timer0_reload_lo = *(undefined1 *)(sVar3 + (ushort)(bVar2 + 1));
    ET0 = 1;
    return;
  }
  timer0_reload_hi = *(undefined1 *)(sVar3 + (ushort)bVar2);
  timer0_reload_lo = *(undefined1 *)(sVar3 + (ushort)(bVar2 + 1));
  return;
}



/* ====================================================================== */
/* Function at 0x20F1: lcd_command */
/* ====================================================================== */

/* Send a command byte to LCD controller.
   Writes to XDATA 0xFF08 (LCD register). */

void lcd_command(void)

{
  byte bVar1;
  char cVar2;
  undefined1 *puVar3;
  
  bVar1 = 0xe0;
  saved_P2_page = 5;
  P2 = 5;
  lcd_write_char(0x80);
  lcd_write_digit();
  lcd_write_char(0xc0);
  cVar2 = '\x10';
  puVar3 = (undefined1 *)0xff09;
  do {
    *puVar3 = *(undefined1 *)(ushort)bVar1;
    lcd_set_cursor();
    bVar1 = bVar1 + 1;
    cVar2 = cVar2 + -1;
  } while (cVar2 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x2106: lcd_write_digit */
/* ====================================================================== */

/* Write a single digit character to LCD. */

void lcd_write_digit(byte param_1)

{
  char cVar1;
  undefined1 *puVar2;
  
  cVar1 = '\x10';
  puVar2 = (undefined1 *)0xff09;
  do {
    *puVar2 = *(undefined1 *)(ushort)param_1;
    lcd_set_cursor();
    param_1 = param_1 + 1;
    cVar1 = cVar1 + -1;
  } while (cVar1 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x2114: lcd_write_char */
/* ====================================================================== */

/* Write a character to LCD display at current position. */

void lcd_write_char(undefined1 param_1)

{
  LCD_CMD_DATA = param_1;
  lcd_set_cursor();
  nop();
  nop();
  nop();
  nop();
  nop();
  return;
}



/* ====================================================================== */
/* Function at 0x2121: lcd_set_cursor */
/* ====================================================================== */

/* Set LCD cursor position. */

undefined1 lcd_set_cursor(undefined1 param_1)

{
  char cVar1;
  
  cVar1 = '\x13';
  do {
    cVar1 = cVar1 + -1;
  } while (cVar1 != '\0');
  return param_1;
}



/* ====================================================================== */
/* Function at 0x212B: lcd_write_space */
/* ====================================================================== */

/* Write a space character to LCD. */

void lcd_write_space(void)

{
  byte bVar1;
  char cVar2;
  undefined1 *puVar3;
  
  lcd_write_byte_hex();
  bVar1 = 0xe0;
  saved_P2_page = 5;
  P2 = 5;
  lcd_write_char(0x80);
  lcd_write_digit();
  lcd_write_char(0xc0);
  cVar2 = '\x10';
  puVar3 = (undefined1 *)0xff09;
  do {
    *puVar3 = *(undefined1 *)(ushort)bVar1;
    lcd_set_cursor();
    bVar1 = bVar1 + 1;
    cVar2 = cVar2 + -1;
  } while (cVar2 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x2130: lcd_write_byte_hex */
/* ====================================================================== */

/* Write a byte value in hex/decimal format to LCD. */

void lcd_write_byte_hex(short param_1)

{
  byte bVar1;
  byte bVar2;
  
  saved_P2_page = 5;
  P2 = 5;
  bVar1 = 0xe0;
  bVar2 = 0;
  do {
    *(undefined1 *)(ushort)bVar1 = *(undefined1 *)(param_1 + (ushort)bVar2);
    bVar1 = bVar1 + 1;
    bVar2 = bVar2 + 1;
  } while (bVar2 != 0x20);
  return;
}



/* ====================================================================== */
/* Function at 0x213A: lcd_busy_wait */
/* ====================================================================== */

/* Wait for LCD busy flag to clear before next write. */

void lcd_busy_wait(short param_1,byte param_2,byte param_3)

{
  do {
    *(undefined1 *)(ushort)param_2 = *(undefined1 *)(param_1 + (ushort)param_3);
    param_2 = param_2 + 1;
    param_3 = param_3 + 1;
  } while (param_3 != 0x20);
  return;
}



/* ====================================================================== */
/* Function at 0x2143: display_track_mode_screen */
/* ====================================================================== */

/* Update LCD for TRACK mode display.
   Shows current part number, track states, position info.
   Returns display pointer 0x03C8 for track mode string table. */

void display_track_mode_screen(void)

{
  char cVar1;
  byte bVar2;
  char cVar3;
  char *pcVar4;
  char *pcVar5;
  undefined1 *puVar6;
  
  lcd_write_byte_hex(0x22c9);
  cVar1 = cEXTMEM00ca;
  saved_P2_page = 4;
  P2 = 4;
  cVar3 = *(char *)(ushort)(byte)(cEXTMEM00ca * '\x02');
  if ((cVar3 != '\0') &&
     ((bVar2 = *(byte *)(ushort)(cEXTMEM00ca * '\x02' + 1),
      pcVar4 = (char *)CONCAT11(cVar3 - (((0xed < bVar2) << 7) >> 7),bVar2 + 0x12),
      pcVar5 = pcVar4 + 1, *pcVar4 != '\0' || (*pcVar5 != '\0')))) {
    puVar6 = (undefined1 *)
             CONCAT11((char)((ushort)pcVar5 >> 8) - (((0xf7 < (byte)pcVar5) << 7) >> 7),
                      (byte)pcVar5 + 8);
    saved_P2_page = 5;
    P2 = 5;
    bVar2 = 0xf1;
    cVar3 = '\x0e';
    do {
      puVar6 = puVar6 + 1;
      *(undefined1 *)(ushort)bVar2 = *puVar6;
      bVar2 = bVar2 + 1;
      cVar3 = cVar3 + -1;
    } while (cVar3 != '\0');
  }
  lcd_write_string_inline(0xd,cVar1);
  LCD_CMD_DATA = 0x8d;
  lcd_set_cursor();
  nop();
  nop();
  nop();
  nop();
  nop();
  return;
}



/* ====================================================================== */
/* Function at 0x2193: display_song_mode_screen */
/* ====================================================================== */

/* Update LCD for SONG mode display.
   Shows song step, part assignments, position info.
   Returns display pointer 0x04B7 for song mode string table. */

void display_song_mode_screen(void)

{
  char cVar1;
  byte bVar2;
  char cVar3;
  char *pcVar4;
  
  lcd_write_byte_hex(0x22a9);
  cVar1 = cEXTMEM00ca;
  saved_P2_page = 5;
  P2 = 5;
  bVar2 = (cEXTMEM00ca + '\x01') * '\x02';
  cVar3 = *(char *)(ushort)bVar2;
  if (cVar3 != '\0') {
    pcVar4 = (char *)CONCAT11(cVar3,*(undefined1 *)(ushort)(bVar2 + 1));
    if ((*pcVar4 != '\x12') || (pcVar4[1] != '\0')) {
      pcVar4 = pcVar4 + 2;
      bVar2 = 0xf1;
      cVar3 = '\x0e';
      do {
        pcVar4 = pcVar4 + 1;
        *(char *)(ushort)bVar2 = *pcVar4;
        bVar2 = bVar2 + 1;
        cVar3 = cVar3 + -1;
      } while (cVar3 != '\0');
    }
  }
  lcd_write_string_inline(0xd,cVar1);
  LCD_CMD_DATA = 0x8d;
  lcd_set_cursor();
  nop();
  nop();
  nop();
  nop();
  nop();
  return;
}



/* ====================================================================== */
/* Function at 0x21CF: format_number_2digit */
/* ====================================================================== */

/* Format and display a 2-digit number on LCD. */

void format_number_2digit(char param_1)

{
  cEXTMEMff09 = param_1 + '0';
  lcd_set_cursor();
  nop();
  nop();
  nop();
  nop();
  return;
}



/* ====================================================================== */
/* Function at 0x21EE: lcd_write_string_inline */
/* ====================================================================== */

/* Write an inline string to LCD from code memory. */

void lcd_write_string_inline(char param_1,byte param_2)

{
  char cVar1;
  char cVar2;
  byte bVar3;
  undefined1 *puVar4;
  
  P2 = 5;
  bVar3 = param_1 - 0x20;
  cVar2 = '\0';
  while( true ) {
    cVar1 = (param_2 < 100) << 7;
    if (cVar1 < '\0') break;
    param_2 = param_2 - ('d' - (cVar1 >> 7));
    cVar2 = cVar2 + '\x01';
  }
  if (cVar2 != '\0') {
    *(char *)(ushort)bVar3 = cVar2 + '0';
    bVar3 = param_1 - 0x1f;
  }
  cVar2 = '\0';
  while( true ) {
    cVar1 = (param_2 < 10) << 7;
    if (cVar1 < '\0') break;
    param_2 = param_2 - ('\n' - (cVar1 >> 7));
    cVar2 = cVar2 + '\x01';
  }
  *(char *)(ushort)bVar3 = cVar2 + '0';
  *(byte *)(ushort)(bVar3 + 1) = param_2 + 0x30;
  bVar3 = 0xe0;
  saved_P2_page = 5;
  P2 = 5;
  lcd_write_char(0x80);
  lcd_write_digit();
  lcd_write_char(0xc0);
  cVar2 = '\x10';
  puVar4 = (undefined1 *)0xff09;
  do {
    *puVar4 = *(undefined1 *)(ushort)bVar3;
    lcd_set_cursor();
    bVar3 = bVar3 + 1;
    cVar2 = cVar2 + -1;
  } while (cVar2 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x222C: lcd_write_part_name */
/* ====================================================================== */

/* Write part/sequence name to LCD display. */

void lcd_write_part_name(char param_1,byte param_2)

{
  char cVar1;
  byte bVar2;
  char cVar3;
  undefined1 *puVar4;
  
  P2 = 5;
  cVar3 = '\0';
  while( true ) {
    cVar1 = (param_2 < 100) << 7;
    if (cVar1 < '\0') break;
    param_2 = param_2 - ('d' - (cVar1 >> 7));
    cVar3 = cVar3 + '\x01';
  }
  *(char *)(ushort)(param_1 - 0x20) = cVar3 + '0';
  cVar3 = '\0';
  while( true ) {
    cVar1 = (param_2 < 10) << 7;
    if (cVar1 < '\0') break;
    param_2 = param_2 - ('\n' - (cVar1 >> 7));
    cVar3 = cVar3 + '\x01';
  }
  *(char *)(ushort)(param_1 - 0x1f) = cVar3 + '0';
  *(byte *)(ushort)(param_1 - 0x1e) = param_2 + 0x30;
  bVar2 = 0xe0;
  saved_P2_page = 5;
  P2 = 5;
  lcd_write_char(0x80);
  lcd_write_digit();
  lcd_write_char(0xc0);
  cVar3 = '\x10';
  puVar4 = (undefined1 *)0xff09;
  do {
    *puVar4 = *(undefined1 *)(ushort)bVar2;
    lcd_set_cursor();
    bVar2 = bVar2 + 1;
    cVar3 = cVar3 + -1;
  } while (cVar3 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x2E20: data_transfer_helper */
/* ====================================================================== */

/* Helper for data transfer operations. */

void data_transfer_helper(void)

{
  bEXTMEM04ce = bEXTMEM04ce ^ key_edge_col1;
  IO_LED_DATA = ~bEXTMEM04ce;
  return;
}



/* ====================================================================== */
/* Function at 0x2E2D: check_data_transfer_state */
/* ====================================================================== */

/* Check data transfer (tape/MIDI dump) state.
   Monitors tape interface and MIDI sysex dump status. */

void check_data_transfer_state(void)

{
  if (_5_2 != '\0') {
    if (_d_5 == '\0') {
      _d_5 = '\x01';
      IO_STATUS_LATCH = IO_STATUS_LATCH & 0xbf;
    }
    else {
      _d_5 = '\0';
      IO_STATUS_LATCH = IO_STATUS_LATCH | 0x40;
    }
  }
  if (_5_1 != '\0') {
    if (_d_6 == '\0') {
      _d_6 = '\x01';
      IO_STATUS_LATCH = IO_STATUS_LATCH & 0xdf;
    }
    else {
      _d_6 = '\0';
      IO_STATUS_LATCH = IO_STATUS_LATCH | 0x20;
    }
  }
  return;
}



/* ====================================================================== */
/* Function at 0x2E9E: load_sequence_from_storage */
/* ====================================================================== */

/* Load a sequence/part from XDATA storage.
   Reads sequence headers and data pointers from XDATA bank. */

void load_sequence_from_storage(byte param_1,char param_2)

{
  bool bVar1;
  byte bVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte bVar5;
  char cVar6;
  byte bVar7;
  char cVar8;
  byte *pbVar9;
  
  if (_d_4 != '\x01') {
    update_display_full();
    pbVar3 = (byte *)0x5d;
    cEXTMEM04cd = '\b';
    do {
      bVar5 = *pbVar3;
      pbVar4 = pbVar3 + '\x01';
      pbVar3 = pbVar3 + '\x02';
      if (*(char *)CONCAT11(*pbVar4 - (((0xfb < bVar5) << 7) >> 7),bVar5 + 4) < '\0') {
        cEXTMEM04cd = '\t' - cEXTMEM04cd;
        goto sequence_data_operations;
      }
      cEXTMEM04cd = cEXTMEM04cd + -1;
    } while (cEXTMEM04cd != '\0');
    cEXTMEM04cd = '\0';
  }
sequence_data_operations:
  update_display_full();
  saved_P2_page = 4;
  P2 = 4;
  current_track_idx = cEXTMEM00ca;
  seq_start_ptr_lo = bEXTMEM00cc;
  if (bEXTMEM00cc == 0) {
    seq_start_ptr_lo = 1;
  }
  bVar5 = bEXTMEM00cd;
  if (bEXTMEM00cd == 0) {
    bVar5 = 1;
  }
  if (bVar5 != seq_start_ptr_lo) {
    seq_start_ptr_hi = bVar5;
    if (bVar5 < seq_start_ptr_lo) {
      cVar8 = (seq_start_ptr_lo - 2) * '\x02';
      BANK0_R2 = *(undefined1 *)(cVar8 + ']');
      BANK0_R3 = *(undefined1 *)(cVar8 + '^');
      if (bVar5 == 1) {
        cVar8 = *(char *)(ushort)(byte)(cEXTMEM00ca * '\x02');
        bVar2 = *(byte *)(ushort)(cEXTMEM00ca * '\x02' + 1);
        pbVar9 = (byte *)CONCAT11(cVar8,bVar2);
        bVar5 = *pbVar9;
        bVar7 = bVar5 + bVar2;
        cVar8 = pbVar9[1] + (cVar8 - ((CARRY1(bVar5,bVar2) << 7) >> 7));
        bVar5 = bVar7 - param_1;
      }
      else {
        cVar8 = (bVar5 - 2) * '\x02';
        bVar7 = *(byte *)(cVar8 + ']');
        bVar5 = bVar7 - param_1;
        cVar8 = *(char *)(cVar8 + '^');
      }
      cVar8 = cVar8 - (param_2 - (((bVar7 < param_1) << 7) >> 7));
      sequence_data_seek(bEXTMEM00cf,cEXTMEM00d0);
      cVar6 = cEXTMEM00d4;
      bVar7 = bEXTMEM00d3;
      bVar1 = CARRY1(bEXTMEM00cf,bVar5);
      bEXTMEM00cf = bEXTMEM00cf + bVar5;
      cEXTMEM00d0 = cEXTMEM00d0 + (cVar8 - ((bVar1 << 7) >> 7));
      bVar1 = CARRY1(bEXTMEM00d1,bVar5);
      bEXTMEM00d1 = bEXTMEM00d1 + bVar5;
      cEXTMEM00d2 = cEXTMEM00d2 + (cVar8 - ((bVar1 << 7) >> 7));
      pbVar9 = (byte *)CONCAT11(*(undefined1 *)(ushort)(byte)(current_track_idx * '\x02'),
                                *(undefined1 *)(ushort)(current_track_idx * '\x02' + 1));
      if (seq_start_ptr_hi == 1) {
        bVar1 = *pbVar9 < bEXTMEM00d3;
        *pbVar9 = *pbVar9 - bEXTMEM00d3;
        pbVar9[1] = pbVar9[1] - (cVar6 - ((bVar1 << 7) >> 7));
        pbVar9 = pbVar9 + 2;
        cVar8 = '\t';
      }
      else {
        cVar8 = '\n';
      }
      bVar5 = (cVar8 - seq_start_ptr_lo) * '\x02';
      pbVar9 = (byte *)CONCAT11((char)((ushort)pbVar9 >> 8) -
                                ((CARRY1(bVar5,(byte)pbVar9) << 7) >> 7),bVar5 + (byte)pbVar9);
      cVar8 = seq_start_ptr_lo - seq_start_ptr_hi;
      do {
        bVar5 = *pbVar9;
        *pbVar9 = bVar5 - bVar7;
        pbVar9[1] = pbVar9[1] - (cVar6 - (((bVar5 < bVar7) << 7) >> 7));
        pbVar9 = pbVar9 + 2;
        cVar8 = cVar8 + -1;
      } while (cVar8 != '\0');
    }
    else {
      cVar8 = (bVar5 - 2) * '\x02';
      bVar5 = *(byte *)(cVar8 + ']');
      bVar7 = bEXTMEM00cf - bVar5;
      cVar6 = cEXTMEM00d0 - (*(char *)(cVar8 + '^') - (((bEXTMEM00cf < bVar5) << 7) >> 7));
      sequence_data_read(bEXTMEM00cf - 1,cEXTMEM00d0 + (((bEXTMEM00cf == 0) << 7) >> 7),bEXTMEM00d1,
                         cEXTMEM00d2);
      cVar8 = cEXTMEM00d4;
      bVar5 = bEXTMEM00d3;
      bVar1 = bEXTMEM00cf < bVar7;
      bEXTMEM00cf = bEXTMEM00cf - bVar7;
      cEXTMEM00d0 = cEXTMEM00d0 - (cVar6 - ((bVar1 << 7) >> 7));
      bVar1 = bEXTMEM00d1 < bVar7;
      bEXTMEM00d1 = bEXTMEM00d1 - bVar7;
      cEXTMEM00d2 = cEXTMEM00d2 - (cVar6 - ((bVar1 << 7) >> 7));
      pbVar9 = (byte *)CONCAT11(*(undefined1 *)(ushort)(byte)(current_track_idx * '\x02'),
                                *(undefined1 *)(ushort)(current_track_idx * '\x02' + 1));
      if (seq_start_ptr_lo == 1) {
        bVar1 = CARRY1(*pbVar9,bEXTMEM00d3);
        *pbVar9 = *pbVar9 + bEXTMEM00d3;
        pbVar9[1] = pbVar9[1] + (cVar8 - ((bVar1 << 7) >> 7));
        pbVar9 = pbVar9 + 2;
        cVar6 = '\t';
      }
      else {
        cVar6 = '\n';
      }
      bVar7 = (cVar6 - seq_start_ptr_hi) * '\x02';
      pbVar9 = (byte *)CONCAT11((char)((ushort)pbVar9 >> 8) -
                                ((CARRY1(bVar7,(byte)pbVar9) << 7) >> 7),bVar7 + (byte)pbVar9);
      cVar6 = seq_start_ptr_hi - seq_start_ptr_lo;
      do {
        bVar7 = *pbVar9;
        *pbVar9 = bVar7 + bVar5;
        pbVar9[1] = pbVar9[1] + (cVar8 - ((CARRY1(bVar7,bVar5) << 7) >> 7));
        pbVar9 = pbVar9 + 2;
        cVar6 = cVar6 + -1;
      } while (cVar6 != '\0');
    }
  }
  bEXTMEM00cc = bEXTMEM00cd;
  update_display_full();
  record_ptr_lo = uEXTMEM04cf;
  record_ptr_hi = uEXTMEM04d0;
  if (cEXTMEM04cc == '\0') {
    BANK2_R2 = -1;
  }
  else {
    BANK2_R2 = *(char *)CONCAT11(4,cEXTMEM04cc + -0x26) + -1;
  }
  return;
}



/* ====================================================================== */
/* Function at 0x2EC8: process_playback_buttons */
/* ====================================================================== */

/* Process button events during active playback.
   Handles mute/unmute, track select, and other controls
   while sequencer is running. */

void process_playback_buttons(void)

{
  char cVar1;
  byte bVar2;
  
  _0_4 = '\0';
  _0_5 = '\0';
  _c_1 = 0;
  if (cEXTMEM04d4 == '\0') {
    _c_3 = 0;
    _d_3 = 0;
    IO_STATUS_LATCH = IO_STATUS_LATCH | 2;
    configure_tempo_timer();
    midi_clock_hi = 0xff;
    midi_clock_lo = 0xff;
    lcd_clear_line();
    _0_5 = 1;
    return;
  }
  if (cEXTMEM04d9 == '\0') {
    return;
  }
  _d_0 = cEXTMEM04d9 == '\x01';
  midi_clock_hi = 0;
  midi_clock_lo = 0;
  lcd_write_byte_hex(0x2389);
  lcd_write_string_inline(0xe,uEXTMEM04ca);
  playback_ptr_hi = cEXTMEM04d9 + '\x01';
  cEXTMEM04ec = '0';
  do {
    lcd_write_string_inline(0x1e,playback_ptr_hi);
    do {
      while( true ) {
        RS1 = 1;
        RS0 = 1;
        process_midi_input();
        RS0 = 0;
        RS1 = 0;
        if (_d_0 != '\x01') {
          clear_track_event_buffers();
        }
        cEXTMEM04ec = cEXTMEM04ec + -1;
        if (cEXTMEM04ec == '\0') {
          cEXTMEM04ec = '0';
          scan_keyboard();
          check_data_transfer_state();
          bVar2 = data_transfer_helper();
          if ((bVar2 & key_edge_col1) != 0) {
            update_part_metadata();
          }
          if ((~bVar2 & key_edge_col1) != 0) {
            init_sequence_part_data();
          }
          if (_0_4 != '\0') {
            set_default_tempo_values();
            if (_d_3 != '\0') {
              if (_c_3 != '\0') {
                all_notes_off_cleanup();
              }
              advance_playback_position();
            }
            return;
          }
          if (_0_5 != '\0') {
            configure_tempo_timer();
            midi_clock_hi = 0xff;
            midi_clock_lo = 0xff;
            return;
          }
        }
        cVar1 = tick_counter;
        if (tick_counter != '\0') break;
        if (_d_0 != '\0') {
          process_recording_step();
        }
      }
      tick_counter = tick_counter + -1;
      click_countdown = click_countdown + -1;
    } while (click_countdown != '\0');
    playback_ptr_hi = playback_ptr_hi + -1;
    if (playback_ptr_hi == '\0') {
      midi_clock_hi = 0xff;
      midi_clock_lo = 0xff;
      click_countdown = 1;
      tick_counter = cVar1;
      return;
    }
    if (playback_ptr_hi == '\x01') {
      _d_0 = '\x01';
    }
    click_countdown = cEXTMEM04d8;
    if (cEXTMEM04d6 != '\0') {
      bVar2 = T1;
      T1 = bVar2 ^ 1;
      bVar2 = T1;
      T1 = bVar2 ^ 1;
    }
  } while( true );
}



/* ====================================================================== */
/* Function at 0x2FB2: send_midi_timing_clock */
/* ====================================================================== */

/* Send MIDI real-time timing clock (0xF8) or other real-time message.
   Parameter selects message: 0xF8=clock, 0xFA=start, 0xFC=stop. */

void send_midi_timing_clock(undefined1 param_1,byte param_2)

{
  if (IO_BEAT_DIVIDER == '\0') {
    return;
  }
  RS1 = 1;
  saved_P2_page = 0;
  P2 = 0;
  ES = 0;
  if (_c_4 != '\x01') {
    TI = 1;
    _c_4 = '\x01';
  }
  *(undefined1 *)(ushort)param_2 = param_1;
  ES = 1;
  RS1 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x2FD3: setup_recording_state */
/* ====================================================================== */

/* Set up internal state for recording.
   Initializes recording pointers, buffers, and flags. */

void setup_recording_state(byte param_1)

{
  char cVar1;
  char cVar2;
  char *pcVar3;
  
  if (IO_BEAT_DIVIDER == '\0') {
    return;
  }
  if (_f_3 != '\0') {
    _f_3 = '\0';
    if (_f_4 == '\0') {
      if (IO_BEAT_DIVIDER == '\0') {
        return;
      }
      RS1 = 1;
      saved_P2_page = 0;
      P2 = 0;
      ES = 0;
      if (_c_4 != '\x01') {
        TI = 1;
        _c_4 = '\x01';
      }
      *(undefined1 *)(ushort)param_1 = 0xfb;
      ES = 1;
      RS1 = 0;
      return;
    }
    _f_4 = '\0';
  }
  if (_f_2 != '\0') {
    cVar1 = decimal_adjust(measure_bcd_lo + 1);
    cVar2 = decimal_adjust(measure_bcd_hi - (((0xfe < measure_bcd_lo) << 7) >> 7));
    if ((cVar2 == total_measures_hi) && (cVar1 == total_measures_lo)) {
      pcVar3 = (char *)0x5cd;
      cEXTMEM05cd = cEXTMEM05cd + '\x01';
      get_song_step_data();
      cEXTMEM00ce = *pcVar3;
      if (cEXTMEM00ce < '\0') {
        pcVar3 = (char *)0x5cd;
        cEXTMEM05cd = '\0';
        get_song_step_data();
        cEXTMEM00ce = *pcVar3;
        update_display_full();
      }
      else {
        update_display_full();
      }
    }
  }
  sequence_edit_operations();
  RS1 = 1;
  saved_P2_page = 0;
  P2 = 0;
  ES = 0;
  if (_c_4 != '\x01') {
    TI = 1;
    _c_4 = '\x01';
  }
  *(undefined1 *)(ushort)param_1 = 0xf2;
  *(byte *)(ushort)(param_1 + 1) = BANK0_R0 & 0x7f;
  *(byte *)(ushort)(param_1 + 2) = (BANK0_R1 & 0x3f) << 1 | BANK0_R0 >> 7;
  *(undefined1 *)(ushort)(param_1 + 3) = 0xfb;
  ES = 1;
  RS1 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x3026: sequence_edit_operations */
/* ====================================================================== */

/* Sequence editing operations (copy, move, merge).
   Manages bulk data operations between parts. */

void sequence_edit_operations(void)

{
  char cVar1;
  undefined1 uVar2;
  undefined1 uVar3;
  byte bVar4;
  char cVar5;
  char cVar6;
  byte bVar7;
  char *pcVar8;
  undefined1 *puVar9;
  byte *pbVar10;
  
  bVar4 = midi_clock_lo + 1;
  cVar1 = midi_clock_hi - (((0xfe < midi_clock_lo) << 7) >> 7);
  cVar5 = memory_block_copy(0x18);
  cVar6 = (char)((ushort)bVar4 * 0x18);
  midi_clock_lo = cVar6 - 1;
  midi_clock_hi = cVar1 * '\x18' + (char)((ushort)bVar4 * 0x18 >> 8) + (((cVar6 == '\0') << 7) >> 7)
  ;
  tick_subdivider = tick_subdivider + cVar5;
  click_countdown = click_countdown + cVar5;
  if ((_f_2 != '\0') && (cEXTMEM05cd != '\0')) {
    playback_ptr_hi = cEXTMEM05cd;
    cEXTMEM05cd = '\0';
    do {
      init_song_playback();
      pcVar8 = (char *)CONCAT11(4,cEXTMEM00ce * '\x02');
      cVar1 = *pcVar8;
      if (cVar1 == '\0') {
        uVar2 = 0x83;
        uVar3 = 6;
      }
      else {
        bVar4 = pcVar8[1];
        puVar9 = (undefined1 *)CONCAT11(cVar1 - (((0xed < bVar4) << 7) >> 7),bVar4 + 0x12);
        uVar2 = *puVar9;
        uVar3 = puVar9[1];
      }
      memory_block_insert(uVar2,uVar3);
      cEXTMEM00cd = cEXTMEM00cd + '\x01';
    } while (cEXTMEM00cd != playback_ptr_hi);
    init_song_playback();
  }
  if (_f_2 == '\0') {
    uEXTMEM05d6 = 0;
    pbVar10 = (byte *)0x4f0;
    cVar1 = '\b';
    do {
      *pbVar10 = midi_clock_lo;
      pbVar10[1] = midi_clock_hi;
      pbVar10 = pbVar10 + 2;
      cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
  }
  else {
    uEXTMEM05d6 = uEXTMEM05d7;
    P2 = 4;
    bVar4 = 0xf0;
    pbVar10 = (byte *)0x5d8;
    do {
      bVar7 = *pbVar10;
      pbVar10 = pbVar10 + 1;
      if (bVar7 == 0) {
        *(byte *)(ushort)bVar4 = midi_clock_lo;
        bVar7 = midi_clock_hi;
      }
      else {
        *(byte *)(ushort)bVar4 = bVar7 + midi_clock_lo;
        bVar7 = midi_clock_hi + (-1 - ((CARRY1(bVar7,midi_clock_lo) << 7) >> 7));
      }
      *(byte *)(ushort)(bVar4 + 1) = bVar7;
      bVar4 = bVar4 + 2;
    } while (bVar4 != 0);
  }
  P2 = saved_P2_page;
  return;
}



/* ====================================================================== */
/* Function at 0x30D9: memory_block_copy */
/* ====================================================================== */

/* Copy a block of data in XDATA memory.
   Used for sequence copy/move operations. */

byte memory_block_copy(byte param_1,byte param_2,byte param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  char cVar4;
  char cVar5;
  byte bVar6;
  byte bVar7;
  
  cVar5 = '\x10';
  cVar4 = '\0';
  bVar7 = 0;
  do {
    bVar3 = param_2 * '\x02';
    bVar2 = param_2 >> 7;
    bVar6 = bVar7 << 1 | param_3 >> 7;
    bVar7 = cVar4 << 1 | bVar7 >> 7;
    if ((bVar7 != 0) || (cVar4 = '\0', BANK0_R6 <= bVar6)) {
      bVar1 = bVar6 < param_1;
      bVar6 = bVar6 - param_1;
      cVar4 = bVar7 + ((bVar1 << 7) >> 7);
      bVar3 = bVar3 + 1;
    }
    cVar5 = cVar5 + -1;
    param_2 = bVar3;
    param_3 = param_3 << 1 | bVar2;
    bVar7 = bVar6;
  } while (cVar5 != '\0');
  return bVar6;
}



/* ====================================================================== */
/* Function at 0x3104: memory_block_insert */
/* ====================================================================== */

/* Insert space in XDATA memory block.
   Shifts data to make room for new events. */

byte memory_block_insert(byte param_1,byte param_2)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  byte bVar4;
  
  bVar1 = (param_1 & 0xf) + (param_1 >> 4) * '\n';
  bVar2 = (byte)((ushort)param_2 * 100);
  cVar3 = bVar2 + bVar1;
  bVar4 = cVar3 - 1;
  return ((((char)((ushort)param_2 * 100 >> 8) - ((CARRY1(bVar2,bVar1) << 7) >> 7)) +
          (((cVar3 == '\0') << 7) >> 7)) * '\x02' | bVar4 >> 7) << 1 | bVar4 * '\x02' >> 7;
}



/* ====================================================================== */
/* Function at 0x315B: lcd_clear_line */
/* ====================================================================== */

/* Clears a line on the LCD display. */

void lcd_clear_line(void)

{
  char cVar1;
  char cVar2;
  char cVar3;
  
  lcd_write_space(0x2d0b);
  cVar1 = '\0';
  cVar2 = '\0';
  cVar3 = '\f';
  do {
    do {
      cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
    cVar2 = cVar2 + -1;
  } while ((cVar2 != '\0') || (cVar3 = cVar3 + -1, cVar3 != '\0'));
  return;
}



/* ====================================================================== */
/* Function at 0x315E: lcd_print_string */
/* ====================================================================== */

/* Print null-terminated string from CODE memory to LCD.
   Takes DPTR (string address in CODE space) as parameter.
   Writes character data to LCD at XDATA 0xFF08. */

void lcd_print_string(void)

{
  char cVar1;
  char cVar2;
  char cVar3;
  
  lcd_write_space();
  cVar1 = '\0';
  cVar2 = '\0';
  cVar3 = '\f';
  do {
    do {
      cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
    cVar2 = cVar2 + -1;
  } while ((cVar2 != '\0') || (cVar3 = cVar3 + -1, cVar3 != '\0'));
  return;
}



/* ====================================================================== */
/* Function at 0x324C: continue_recording_existing */
/* ====================================================================== */

/* Continue recording into an existing (non-empty) sequence.
   Appends new MIDI data to existing track data. */

void continue_recording_existing(void)

{
  sequence_data_operations();
  if (cEXTMEM04cc != '\0') {
    IO_STATUS_LATCH = IO_STATUS_LATCH & 0xfd;
    _c_3 = 1;
    return;
  }
  IO_STATUS_LATCH = IO_STATUS_LATCH | 2;
  _c_3 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x3272: check_transport_buttons */
/* ====================================================================== */

/* Check play/stop/record transport button states.
   Sets flag bits based on which transport buttons are newly pressed. */

void check_transport_buttons(void)

{
                    /* WARNING: Could not recover jumptable at 0x3279. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  (*(code *)CONCAT11(display_ptr_hi,display_ptr_lo))();
  return;
}



/* ====================================================================== */
/* Function at 0x327A: handle_play_button */
/* ====================================================================== */

/* Handle PLAY button press.
   Initiates sequence playback from current position. */

void handle_play_button(void)

{
  solo_track_num = 0;
  play_button_handler_detail();
  _f_5 = 1;
  display_ptr_lo = 0x8c;
  display_ptr_hi = 0x32;
  return;
}



/* ====================================================================== */
/* Function at 0x33A9: play_button_handler_detail */
/* ====================================================================== */

/* Detailed play button handler.
   Manages play/continue logic and external sync. */

void play_button_handler_detail(void)

{
  byte bVar1;
  undefined1 uVar2;
  
  _e_1 = 0;
  if ((solo_track_num >> 1 & 1) == 1) {
    lcd_write_byte_hex(0x28eb);
    bVar1 = cEXTMEM04d7 * '\x03';
    uEXTMEM05eb = *(undefined1 *)((ushort)bVar1 + 0x3475);
    uEXTMEM05ec = *(undefined1 *)((ushort)(bVar1 + 1) + 0x3475);
    uEXTMEM05ed = *(undefined1 *)((ushort)(bVar1 + 2) + 0x3475);
    lcd_write_string_inline(0x1c,uEXTMEM04d9);
    if ((solo_track_num & 1) == 0) {
      uVar2 = 0x8b;
    }
    else {
      uVar2 = 0xcc;
    }
  }
  else {
    lcd_write_byte_hex(0x28cb);
    uEXTMEM05ee = *(undefined1 *)((ushort)(bEXTMEM04d5 * '\x02') + 0x3457);
    uEXTMEM05ef = *(undefined1 *)((ushort)(bEXTMEM04d5 * '\x02' + 1) + 0x3457);
    bVar1 = cEXTMEM04d6 * '\x03';
    uEXTMEM05fd = *(undefined1 *)((ushort)bVar1 + 0x3475);
    uEXTMEM05fe = *(undefined1 *)((ushort)(bVar1 + 1) + 0x3475);
    uEXTMEM05ff = *(undefined1 *)((ushort)(bVar1 + 2) + 0x3475);
    lcd_command();
    if (solo_track_num == 0) {
      uVar2 = 0x8e;
    }
    else {
      uVar2 = 0xcd;
    }
  }
  lcd_write_char(uVar2);
  uEXTMEM04d8 = *(undefined1 *)((ushort)bEXTMEM04d5 + 0x346b);
  return;
}



/* ====================================================================== */
/* Function at 0x347B: handle_record_button */
/* ====================================================================== */

/* Handle RECORD button press.
   Enters record mode (real-time or step depending on context). */

void handle_record_button(void)

{
  solo_track_num = 0;
  record_button_setup();
  _e_1 = 0;
  _e_2 = 0;
  _f_5 = 1;
  display_ptr_lo = 0x91;
  display_ptr_hi = 0x34;
  return;
}



/* ====================================================================== */
/* Function at 0x3561: record_button_setup */
/* ====================================================================== */

/* Record button setup and validation.
   Checks if recording is possible and prepares state. */

void record_button_setup(void)

{
  char cVar1;
  byte bVar2;
  short sVar3;
  
  lcd_write_byte_hex(0x274b);
  lcd_write_part_name(10,bEXTMEM04da);
  lcd_write_char(0x8a);
  sVar3 = 0x1ef1;
  bVar2 = bEXTMEM04da * '\x02';
  if (CARRY1(bEXTMEM04da,bEXTMEM04da)) {
    sVar3 = 0x1ff1;
  }
  cVar1 = ET0;
  if (cVar1 != '\0') {
    ET0 = 0;
    timer0_reload_hi = *(undefined1 *)(sVar3 + (ushort)bVar2);
    timer0_reload_lo = *(undefined1 *)(sVar3 + (ushort)(bVar2 + 1));
    ET0 = 1;
    return;
  }
  timer0_reload_hi = *(undefined1 *)(sVar3 + (ushort)bVar2);
  timer0_reload_lo = *(undefined1 *)(sVar3 + (ushort)(bVar2 + 1));
  return;
}



/* ====================================================================== */
/* Function at 0x357A: handle_stop_continue */
/* ====================================================================== */

/* Handle STOP/CONTINUE button press.
   Stops playback or continues from paused position. */

void handle_stop_continue(void)

{
  solo_track_num = 0;
  stop_button_handler_detail();
  _f_5 = 1;
  display_ptr_lo = 0x8c;
  display_ptr_hi = 0x35;
  return;
}



/* ====================================================================== */
/* Function at 0x364D: stop_button_handler_detail */
/* ====================================================================== */

/* Detailed stop button processing.
   Handles stop vs pause depending on current state. */

void stop_button_handler_detail(void)

{
  byte bVar1;
  byte bVar2;
  
  bVar2 = (solo_track_num << 1 | solo_track_num >> 7) << 1;
  bVar1 = (bVar2 | (solo_track_num << 1) >> 7) << 1;
  bVar2 = (bVar1 | bVar2 >> 7) << 1;
  bVar2 = (bVar2 | bVar1 >> 7) << 1 | bVar2 >> 7;
  lcd_write_byte_hex(CONCAT11('\'' - (((0x74 < bVar2) << 7) >> 7),bVar2 + 0x8b));
                    /* WARNING: Could not recover jumptable at 0x3668. Too many branches */
                    /* WARNING: Treating indirect jump as call */
  (*(code *)((ushort)((solo_track_num << 1 | solo_track_num >> 7) << 1 | (solo_track_num << 1) >> 7)
            + 0x3692))();
  return;
}



/* ====================================================================== */
/* Function at 0x3F94: handle_copy_function */
/* ====================================================================== */

/* Handle COPY function button.
   Copies sequence data between parts/tracks. */

void handle_copy_function(void)

{
  solo_track_num = 0;
  if (_f_2 == '\0') {
    display_track_mode_screen();
  }
  else {
    display_song_mode_screen();
  }
  lcd_write_char(0xc1);
  display_ptr_lo = 0xb2;
  display_ptr_hi = 0x3f;
  return;
}



/* ====================================================================== */
/* Function at 0x407D: handle_delete_function */
/* ====================================================================== */

/* Handle DELETE function button.
   Deletes sequence data for selected part/track. */

void handle_delete_function(void)

{
  solo_track_num = 0;
  delete_function_impl();
  display_ptr_lo = 0x8d;
  display_ptr_hi = 0x40;
  return;
}



/* ====================================================================== */
/* Function at 0x4107: delete_function_impl */
/* ====================================================================== */

/* Delete function implementation.
   Erases sequence data for selected track or part. */

void delete_function_impl(void)

{
  byte bVar1;
  undefined1 uVar2;
  char *pcVar3;
  undefined1 *puVar4;
  
  bVar1 = (solo_track_num >> 4 | solo_track_num << 4) << 1 | (solo_track_num << 4) >> 7;
  uVar2 = 0x28;
  if (0x94 < bVar1) {
    uVar2 = 0x29;
  }
  pcVar3 = (char *)CONCAT11(uVar2,bVar1 + 0x6b);
  lcd_write_byte_hex();
  if (solo_track_num == 0) {
    bVar1 = IO_TRANSPORT_STATE >> 4 | IO_TRANSPORT_STATE << 4;
    uVar2 = 0x41;
    if (0x9b < bVar1) {
      uVar2 = 0x42;
    }
    delete_confirm(CONCAT11(uVar2,bVar1 + 100));
    lcd_command();
    LCD_CMD_DATA = 0xc0;
  }
  else {
    delete_track_data();
    if (*pcVar3 == '\0') {
      puVar4 = (undefined1 *)0x3475;
    }
    else {
      puVar4 = (undefined1 *)0x3478;
    }
    uEXTMEM05f8 = *puVar4;
    uEXTMEM05f9 = puVar4[1];
    uEXTMEM05fa = puVar4[2];
    lcd_command();
    LCD_CMD_DATA = 200;
  }
  lcd_set_cursor();
  nop();
  nop();
  nop();
  nop();
  nop();
  return;
}



/* ====================================================================== */
/* Function at 0x4195: delete_confirm */
/* ====================================================================== */

/* Delete confirmation and execution. */

void delete_confirm(short param_1)

{
  byte bVar1;
  byte bVar2;
  
  bVar2 = 0x10;
  saved_P2_page = 5;
  P2 = 5;
  bVar1 = 0xff;
  do {
    *(undefined1 *)(ushort)bVar1 = *(undefined1 *)(param_1 + (ushort)bVar2);
    bVar1 = bVar1 - 1;
    bVar2 = bVar2 - 1;
  } while (bVar2 != 0);
  return;
}



/* ====================================================================== */
/* Function at 0x41A6: delete_track_data */
/* ====================================================================== */

/* Delete a single track's data from a part. */

void delete_track_data(void)

{
  return;
}



/* ====================================================================== */
/* Function at 0x47A1: init_song_playback */
/* ====================================================================== */

/* Initialize song mode playback.
   Sets up song step pointer and loads first part. */

void init_song_playback(char *param_1)

{
  get_song_step_data();
  cEXTMEM00ce = *param_1;
  if (-1 < *param_1) {
    cEXTMEM04ce = param_1[1];
  }
  return;
}



/* ====================================================================== */
/* Function at 0x47B2: get_song_step_data */
/* ====================================================================== */

/* Get data for current song step.
   Reads part assignment from song sequence table in XDATA.
   Called to advance through song step chain. */

char get_song_step_data(void)

{
  byte bVar1;
  
  saved_P2_page = 5;
  P2 = 5;
  bVar1 = (cEXTMEM00ca + '\x01') * '\x02';
  return *(char *)(ushort)bVar1 +
         ((-(((0xeeU < (byte)(cEXTMEM00cd * '\x02')) << 7) >> 7) - (cEXTMEM00cd >> 7)) -
         ((CARRY1(*(byte *)(ushort)(bVar1 + 1),cEXTMEM00cd * '\x02' + 0x11) << 7) >> 7));
}



/* ====================================================================== */
/* Function at 0x47E1: process_midi_realtime_msgs */
/* ====================================================================== */

/* Process MIDI real-time messages (clock, start, stop, continue).
   Handles external sync: MIDI clock for tempo slave,
   start/stop/continue for transport control from external sequencer. */

void process_midi_realtime_msgs(void)

{
  bool bVar1;
  undefined1 *puVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  char cVar6;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  char cVar10;
  byte *pbVar11;
  byte *pbVar12;
  
  saved_P2_page = 2;
  P2 = 2;
  if (cEXTMEM00bb == '\0') {
    return;
  }
  _f_4 = 1;
  cEXTMEM00bb = 0;
  bVar9 = bEXTMEM00bd >> 1;
  bVar3 = bEXTMEM00bc & 0x7f | bEXTMEM00bd << 7;
  if (_f_2 != '\0') {
    cEXTMEM05cd = '\0';
    init_song_playback();
  }
LAB_CODE_4808:
  do {
    update_display_full();
    bVar4 = (total_measures_lo & 0xf) + (total_measures_lo >> 4) * '\n';
    bVar5 = (byte)((ushort)total_measures_hi * 100);
    cVar6 = bVar5 + bVar4;
    bVar7 = cVar6 - 1;
    bVar8 = bVar3 + bVar7 * -4;
    bVar4 = (((((char)((ushort)total_measures_hi * 100 >> 8) - ((CARRY1(bVar5,bVar4) << 7) >> 7)) +
              (((cVar6 == '\0') << 7) >> 7)) * '\x02' | bVar7 >> 7) << 1 | bVar7 * '\x02' >> 7) -
            (((bVar3 < bVar7 * '\x04') << 7) >> 7);
    bVar5 = bVar9 - bVar4;
    if ((bVar9 < bVar4) << 7 < '\0') {
      bVar4 = (byte)((ushort)bVar3 * 0x18);
      cVar6 = bVar9 * '\x18' + (char)((ushort)bVar3 * 0x18 >> 8);
      puVar2 = (undefined1 *)0x5d;
      current_track_idx = '\0';
      active_track_mask = bVar3;
      track_bit_rotate = bVar9;
      do {
        cVar10 = puVar2['\x01'];
        pbVar12 = (byte *)CONCAT11(cVar10,*puVar2);
        if (cVar10 != '\0') {
          while (pbVar11 = pbVar12 + 1, pbVar12 = pbVar12 + 2,
                *pbVar12 < (byte)(cVar6 - (((*pbVar11 < bVar4) << 7) >> 7))) {
            do {
              pbVar12 = pbVar12 + 5;
            } while (-1 < (char)*pbVar12);
            *puVar2 = (char)pbVar12;
            puVar2['\x01'] = (char)((ushort)pbVar12 >> 8);
          }
        }
        puVar2 = puVar2 + '\x02';
        current_track_idx = current_track_idx + '\x01';
      } while (current_track_idx != '\b');
      midi_clock_lo = bVar4 - 1;
      midi_clock_hi = cVar6 + (((bVar4 == 0) << 7) >> 7);
      tick_subdivider = *(undefined1 *)((ushort)(active_track_mask & 3) + 0x4967);
      bVar3 = (active_track_mask >> 1 | track_bit_rotate << 7) >> 1 | (track_bit_rotate >> 1) << 7;
      bVar9 = (track_bit_rotate >> 2) - (((0xfe < bVar3) << 7) >> 7);
      bVar3 = bVar3 + 1;
      do {
        bVar4 = bVar3;
        cVar10 = measure_bcd_hi;
        cVar6 = ((bVar4 < 100) << 7) >> 7;
        bVar1 = (byte)-cVar6 <= bVar9;
        bVar9 = bVar9 + cVar6;
        measure_bcd_hi = measure_bcd_hi + '\x01';
        bVar3 = bVar4 + 0x9c;
      } while (bVar1);
      measure_bcd_lo = bVar4 / 10 >> 4 | bVar4 / 10 << 4 | bVar4 % 10;
      cVar6 = cEXTMEM04d8;
      measure_bcd_hi = cVar10;
      cVar10 = memory_block_copy(BANK0_R4,BANK0_R5);
      click_countdown = (cVar6 - cVar10) + '\x01';
      if (_f_2 == '\0') {
        uEXTMEM05d6 = 0;
        pbVar12 = (byte *)0x4f0;
        cVar6 = '\b';
        do {
          *pbVar12 = midi_clock_lo;
          pbVar12[1] = midi_clock_hi;
          pbVar12 = pbVar12 + 2;
          cVar6 = cVar6 + -1;
        } while (cVar6 != '\0');
      }
      else {
        uEXTMEM05d6 = uEXTMEM05d7;
        P2 = 4;
        bVar9 = 0xf0;
        pbVar12 = (byte *)0x5d8;
        do {
          bVar3 = *pbVar12;
          pbVar12 = pbVar12 + 1;
          if (bVar3 == 0) {
            *(byte *)(ushort)bVar9 = midi_clock_lo;
            bVar3 = midi_clock_hi;
          }
          else {
            *(byte *)(ushort)bVar9 = bVar3 + midi_clock_lo;
            bVar3 = midi_clock_hi + (-1 - ((CARRY1(bVar3,midi_clock_lo) << 7) >> 7));
          }
          *(byte *)(ushort)(bVar9 + 1) = bVar3;
          bVar9 = bVar9 + 2;
        } while (bVar9 != 0);
      }
      P2 = saved_P2_page;
      return;
    }
    if (_f_2 != '\0') {
      cEXTMEM05cd = cEXTMEM05cd + '\x01';
      init_song_playback();
      bVar3 = bVar8;
      bVar9 = bVar5;
      if (-1 < cEXTMEM05ce) goto LAB_CODE_4808;
      cEXTMEM05cd = '\0';
      init_song_playback();
    }
    bVar3 = bVar8;
    bVar9 = bVar5;
    if (_d_5 != '\x01') {
      if (_f_2 != '\0') {
        cEXTMEM05cd = '\0';
        init_song_playback();
      }
      update_display_full();
      return;
    }
  } while( true );
}



/* ====================================================================== */
/* Function at 0x4C77: recalculate_sequence_length */
/* ====================================================================== */

/* Recalculate sequence length after edit.
   Updates part length counters after recording or deletion. */

void recalculate_sequence_length(byte param_1,char param_2)

{
  byte bVar1;
  undefined *puVar2;
  undefined1 uVar3;
  char cVar4;
  char cVar5;
  undefined1 *puVar6;
  char *pcVar7;
  char *pcVar8;
  
  pcVar8 = (char *)CONCAT11(4,cEXTMEM04ca * '\x02');
  bVar1 = pcVar8[1];
  puVar6 = (undefined1 *)CONCAT11(*pcVar8 - (((0xed < bVar1) << 7) >> 7),bVar1 + 0x12);
  memory_block_insert(*puVar6,puVar6[1]);
  uVar3 = (undefined1)((ushort)param_1 * 0x18);
  cVar4 = param_2 * '\x18' + (char)((ushort)param_1 * 0x18 >> 8);
  update_display_full();
  puVar2 = (undefined *)0x5d;
LAB_CODE_4ca9:
  pcVar8 = (char *)CONCAT11(puVar2['\x01'],*puVar2);
  puVar2 = puVar2 + '\x02';
  do {
    if (*pcVar8 < '\0') {
      pcVar7 = pcVar8 + 4;
      if ((-1 < pcVar8[3]) && (*pcVar7 < '\0')) break;
    }
    else {
      pcVar7 = pcVar8 + 2;
    }
    pcVar8 = pcVar7 + 3;
  } while( true );
  cVar5 = (char)((ushort)pcVar7 >> 8);
  if ((byte)pcVar7 < 3) {
    cVar5 = cVar5 + -1;
  }
  puVar6 = (undefined1 *)CONCAT11(cVar5,(byte)pcVar7 - 3);
  *puVar6 = uVar3;
  puVar6[1] = cVar4;
  if (puVar2 == &current_track_idx) {
    return;
  }
  goto LAB_CODE_4ca9;
}



/* ====================================================================== */
/* Function at 0x5053: handle_tempo_edit_button */
/* ====================================================================== */

/* Handle tempo editing.
   Enters tempo edit mode, adjusts BPM value. */

void handle_tempo_edit_button(void)

{
  undefined1 *puVar1;
  
  solo_track_num = 0;
  DAT_INTMEM_4a = 0;
  DAT_INTMEM_49 = 0;
  BANK1_R6 = 0;
  BANK1_R5 = 1;
  puVar1 = (undefined1 *)0x4ca;
  if (_f_2 != '\0') {
    puVar1 = (undefined1 *)0x5ca;
  }
  BANK1_R7 = *puVar1;
  _e_2 = 0;
  _e_1 = 0;
  IO_LED_DATA = 0;
  tempo_edit_impl();
  display_ptr_lo = 0x84;
  display_ptr_hi = 0x50;
  return;
}



/* ====================================================================== */
/* Function at 0x5162: tempo_edit_impl */
/* ====================================================================== */

/* Tempo edit mode implementation.
   Handles BPM increment/decrement with up/down buttons. */

void tempo_edit_impl(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  undefined1 uVar5;
  undefined1 *puVar6;
  
  if (_f_2 == '\0') {
    lcd_write_byte_hex(0x2449);
    if (solo_track_num != 0) {
      bVar3 = solo_track_num;
      if (7 < solo_track_num) {
        bVar3 = 7;
      }
      bVar4 = (byte)((ushort)bVar3 * 10);
      bVar1 = 0xef;
      bVar2 = 10;
      do {
        *(undefined1 *)(ushort)bVar1 =
             *(undefined1 *)
              (CONCAT11((char)((ushort)bVar3 * 10 >> 8) + ('$' - (((0x91 < bVar4) << 7) >> 7)),
                        bVar4 + 0x6e) + (ushort)bVar2);
        bVar1 = bVar1 - 1;
        bVar2 = bVar2 - 1;
      } while (bVar2 != 0);
      delete_confirm(0x2468);
      if (6 < solo_track_num) {
        bEXTMEM00ee = solo_track_num + 0x2a;
        if (bEXTMEM00ee >= 0x3a) {
          cEXTMEM00ef = bEXTMEM00ee - ('\n' - (((bEXTMEM00ee < 0x3a) << 7) >> 7));
          bEXTMEM00ee = 0x31;
        }
      }
    }
    puVar6 = (undefined1 *)0x4ca;
  }
  else {
    lcd_write_byte_hex(0x24bf);
    puVar6 = (undefined1 *)0x5ca;
  }
  if (solo_track_num == 0) {
    uVar5 = 0x11;
  }
  else {
    uVar5 = 0x16;
  }
  lcd_write_string_inline(uVar5,*puVar6);
  lcd_write_string_inline(0x1c,BANK1_R7);
  lcd_write_char(0xcc);
  return;
}



/* ====================================================================== */
/* Function at 0x599A: handle_track_select_button */
/* ====================================================================== */

/* Handle track selection button press (tracks 0-7).
   Selects active track for recording/editing/muting. */

void handle_track_select_button(void)

{
  if (_f_2 == '\0') {
    display_track_mode_screen();
  }
  else {
    display_song_mode_screen();
  }
  if ((_f_2 != '\0') && (cEXTMEM05ce == -1)) {
    return;
  }
  track_select_impl();
  _e_1 = 0;
  _e_2 = 0;
  DAT_INTMEM_4a = 0x50;
  DAT_INTMEM_49 = 0x28;
  display_ptr_lo = 200;
  display_ptr_hi = 0x59;
  return;
}



/* ====================================================================== */
/* Function at 0x5AE5: track_select_impl */
/* ====================================================================== */

/* Track select implementation.
   Switches active track and updates display. */

void track_select_impl(void)

{
  byte bVar1;
  
  if (_f_2 != '\0') {
    lcd_write_byte_hex(0x22e9);
    bVar1 = (cEXTMEM05cd + 1U) % 100;
    cEXTMEM05ed = (cEXTMEM05cd + 1U) / 100 + 0x30;
    cEXTMEM05ee = bVar1 / 10 + 0x30;
    cEXTMEM05ef = bVar1 % 10 + 0x30;
    cEXTMEM05f5 = bEXTMEM05ce / 10 + 0x30;
    cEXTMEM05f6 = bEXTMEM05ce % 10 + 0x30;
    lcd_write_string_inline(5,uEXTMEM05ca);
    format_bcd_number();
    return;
  }
  if (_d_7 != '\0') {
    format_bcd_number();
    return;
  }
  saved_P2_page = 5;
  P2 = 5;
  lcd_busy_wait(0x2329,0xf0,0x10);
  lcd_command();
  format_bcd_number();
  lcd_write_char(0x8d);
  return;
}



/* ====================================================================== */
/* Function at 0x5CAF: start_recording_new_sequence */
/* ====================================================================== */

/* WARNING: Removing unreachable block (CODE,0x5d7b) */
/* WARNING: Removing unreachable block (CODE,0x5d8a) */
/* WARNING: Removing unreachable block (CODE,0x5d9b) */
/* WARNING: Removing unreachable block (CODE,0x5d87) */
/* Start recording a new sequence from scratch.
   Allocates XDATA memory for new sequence data, initializes headers. */

void start_recording_new_sequence(byte param_1)

{
  bool bVar1;
  char cVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  undefined1 uVar6;
  undefined1 uVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  byte *pbVar12;
  byte bVar15;
  short sVar13;
  byte *pbVar14;
  
  IO_STATUS_LATCH = IO_STATUS_LATCH & 0xf7;
  cVar2 = solo_track_num + '\x01';
  bVar11 = 0;
  bVar5 = 0xff;
  do {
    IO_LED_DATA = bVar5 << 1 | bVar11 >> 7;
    bVar11 = bVar5 & 0x80;
    cVar2 = cVar2 + -1;
    bVar5 = IO_LED_DATA;
  } while (cVar2 != '\0');
  _f_5 = 1;
  display_ptr_lo = 0xd4;
  display_ptr_hi = 0x5c;
  _f_7 = 0;
  saved_P2_page = 5;
  P2 = 5;
  uVar6 = *(undefined1 *)(solo_track_num * '\x02' + ']');
  uVar7 = *(undefined1 *)(solo_track_num * '\x02' + '^');
  pbVar12 = (byte *)CONCAT11(uVar7,uVar6);
  bVar11 = *pbVar12 & 0x7f;
  if (((char)pbVar12[3] < '\0') || (-1 < (char)pbVar12[4])) {
    sVar13 = CONCAT11(uVar7,uVar6);
    pbVar12 = (byte *)(sVar13 + 3);
    current_track_idx = bVar11;
    uEXTMEM00e0 = sysex_dump_helper(*(undefined1 *)(sVar13 + 1),*(undefined1 *)(sVar13 + 2));
    cEXTMEM00e1 = bVar11 / 10 + 0x30;
    cEXTMEM00e2 = bVar11 % 10 + 0x30;
    uEXTMEM00e3 = 0x2f;
    cEXTMEM00e4 = param_1 / 10 + 0x30;
    cEXTMEM00e5 = param_1 % 10 + 0x30;
    uEXTMEM00e6 = 0x3a;
    uEXTMEM00e7 = 0x20;
    bVar11 = *pbVar12;
    bVar5 = pbVar12[1];
    bVar9 = pbVar12[2];
    bVar10 = pbVar12[3];
    pbVar12 = pbVar12 + 4;
    bVar15 = (byte)pbVar12;
    if ((bVar11 & 0x80) != 0) {
      bVar11 = bVar11 & 0x7f;
      active_track_mask = current_track_idx + 0x87;
      if (current_track_idx < 0x79) {
        active_track_mask = 0;
      }
      bVar3 = (active_track_mask << 1 | active_track_mask >> 7) << 1;
      bVar8 = (bVar3 | (active_track_mask << 1) >> 7) << 1 | bVar3 >> 7;
      cVar2 = '\b';
      bVar3 = 0xe8;
      do {
        bVar4 = bVar3;
        *(undefined1 *)(ushort)bVar4 = *(undefined1 *)((ushort)bVar8 + 0x6015);
        bVar3 = bVar4 + 1;
        bVar8 = bVar8 + 1;
        cVar2 = cVar2 + -1;
      } while (cVar2 != '\0');
      if (current_track_idx == 0x7a) {
LAB_CODE_5e8c:
        *(undefined1 *)(ushort)bVar3 = 0x20;
        bVar4 = bVar4 + 2;
        sysex_dump_checksum(bVar11);
        *(undefined1 *)(ushort)bVar4 = 0x20;
        *(undefined1 *)(ushort)(bVar4 + 1) = 0x20;
        *(undefined1 *)(ushort)(bVar4 + 2) = 0x20;
        bVar4 = bVar4 + 3;
      }
      else if (current_track_idx < 0x7a) {
        sysex_dump_checksum();
        *(undefined1 *)(ushort)bVar3 = 0x3a;
        bVar4 = bVar3 + 1;
        sysex_dump_checksum(bVar11);
      }
      else {
        if (current_track_idx != 0x7c) {
          if (current_track_idx < 0x7c) goto LAB_CODE_5e8c;
          cVar2 = (char)((ushort)pbVar12 >> 8) + (((bVar15 < 7) << 7) >> 7);
          if (*(char *)CONCAT11(cVar2,bVar15 - 7) < '\0') {
LAB_CODE_5f6e:
            *(undefined1 *)(ushort)bVar3 = 0x20;
          }
          else {
            pbVar14 = (byte *)CONCAT11(cVar2 + (((bVar15 - 7 < 5) << 7) >> 7),bVar15 - 0xc);
            if ((*pbVar14 & 0x80) == 0) {
              bVar9 = pbVar14[2];
            }
            else {
              bVar9 = *pbVar14 & 0x7f;
            }
            if (((bVar9 != 0x7d) || ((char)pbVar14[4] < '\0')) || ((char)pbVar14[6] < '\0'))
            goto LAB_CODE_5f6e;
            *(undefined1 *)(ushort)bVar3 = 0x7f;
          }
          *(undefined1 *)(ushort)(bVar4 + 2) = 0x20;
          bVar4 = bVar4 + 3;
          sysex_dump_checksum(bVar11);
          *(undefined1 *)(ushort)bVar4 = 0x20;
          bVar4 = bVar4 + 1;
          if (-1 < (char)bVar5) {
            sysex_dump_checksum();
            *(undefined1 *)(ushort)bVar4 = 0x20;
            bVar4 = bVar4 + 1;
            if ((-1 < (char)bVar10) && (sysex_dump_checksum(), *pbVar12 == 0x7d)) {
              *(undefined1 *)(ushort)bVar4 = 0x20;
              *(undefined1 *)(ushort)(bVar4 + 1) = 0x7e;
              bVar4 = bVar4 + 2;
            }
          }
          do {
            *(undefined1 *)(ushort)bVar4 = 0x20;
            bVar4 = bVar4 + 1;
          } while (bVar4 != 0);
          goto LAB_CODE_5feb;
        }
        bVar11 = bVar10 >> 1;
        bVar9 = bVar9 & 0x7f | bVar10 << 7;
        uVar6 = 0x20;
        if ((bVar11 & 0x20) == 0) {
          bVar1 = bVar9 != 0;
          bVar9 = -bVar9;
          bVar11 = 0x20 - (bVar11 - ((bVar1 << 7) >> 7));
          uVar6 = 0x2d;
        }
        else {
          bVar11 = bVar11 & 0xdf;
        }
        *(undefined1 *)(ushort)bVar3 = uVar6;
        bVar10 = bVar11 >> 2 & 0xf;
        bVar11 = (bVar11 & 3) - ((CARRY1(bVar10 * '\x18',bVar9) << 7) >> 7);
        if ((bVar11 >> 2 & 1) == 0) {
          if ((bVar11 == 3) && (0xe7 < bVar10 * '\x18' + bVar9)) {
            bVar11 = 0;
            bVar10 = bVar10 + 1;
          }
        }
        else {
          bVar11 = 0;
          bVar10 = bVar10 + 1;
        }
        *(byte *)(ushort)(bVar4 + 2) = bVar10 + 0x30;
        cVar2 = BANK0_R1;
        bVar11 = memory_block_copy(100,BANK0_R7,BANK0_R0,bVar11);
        *(char *)(ushort)BANK0_R3 = cVar2 + '0';
        *(byte *)(ushort)(BANK0_R3 + 1) = bVar11 / 10 + 0x30;
        *(byte *)(ushort)(BANK0_R3 + 2) = bVar11 % 10 + 0x30;
        *(undefined1 *)(ushort)(BANK0_R3 + 3) = 0x20;
        *(undefined1 *)(ushort)(BANK0_R3 + 4) = 0x20;
        bVar4 = BANK0_R3 + 5;
      }
LAB_CODE_5fab:
      *(undefined1 *)(ushort)bVar4 = 0x20;
      *(undefined1 *)(ushort)(bVar4 + 1) = 0x43;
      *(undefined1 *)(ushort)(bVar4 + 2) = 0x48;
      *(undefined1 *)(ushort)(bVar4 + 3) = 0x41;
      *(undefined1 *)(ushort)(bVar4 + 4) = 0x4e;
      uVar7 = 0x20;
      uVar6 = 0x20;
      if (*(char *)CONCAT11(4,solo_track_num + -0x25) != '\0') {
        uVar7 = 0x28;
        uVar6 = 0x29;
      }
      *(undefined1 *)(ushort)(bVar4 + 5) = uVar7;
      *(byte *)(ushort)(bVar4 + 6) = (bVar5 + 1) / 10 + 0x30;
      *(byte *)(ushort)(bVar4 + 7) = (bVar5 + 1) % 10 + 0x30;
      *(undefined1 *)(ushort)(bVar4 + 8) = uVar6;
      goto LAB_CODE_5feb;
    }
    if (-1 < (char)bVar5) {
      active_track_mask = 5;
      sVar13 = CONCAT11((char)((ushort)current_track_idx * 4 >> 8) + '`',0x3d);
      cVar2 = '\x04';
      bVar15 = 0xe8;
      do {
        bVar3 = bVar15;
        *(undefined1 *)(ushort)bVar3 =
             *(undefined1 *)(sVar13 + ((ushort)current_track_idx * 4 & 0xff));
        sVar13 = sVar13 + 1;
        cVar2 = cVar2 + -1;
        bVar15 = bVar3 + 1;
      } while (cVar2 != '\0');
      *(undefined1 *)(ushort)(bVar3 + 1) = 0x20;
      sysex_dump_checksum(bVar11,bVar3 + 2);
      if (bVar10 == 0) {
        bVar9 = bVar9 + 1;
      }
      bVar10 = memory_block_copy(0x60,BANK0_R4,BANK0_R0);
      cVar2 = '\0';
      bVar11 = BANK0_R0;
      if (bVar9 != 0) {
        cVar2 = '\x02';
        bVar11 = BANK0_R0 + 0x38;
      }
      *(byte *)(ushort)BANK0_R3 = bVar11 / 100 + 0x30 + cVar2;
      *(byte *)(ushort)(BANK0_R3 + 1) = (bVar11 % 100) / 10 + 0x30;
      *(byte *)(ushort)(BANK0_R3 + 2) = (bVar11 % 100) % 10 + 0x30;
      *(undefined1 *)(ushort)(BANK0_R3 + 3) = 0x2f;
      *(byte *)(ushort)(BANK0_R3 + 4) = bVar10 / 10 + 0x30;
      *(byte *)(ushort)(BANK0_R3 + 5) = bVar10 % 10 + 0x30;
      *(undefined1 *)(ushort)(BANK0_R3 + 6) = 0x20;
      bVar4 = BANK0_R3 + 7;
      goto LAB_CODE_5fab;
    }
  }
  active_track_mask = 6;
  lcd_write_byte_hex(0x2d8b);
LAB_CODE_5feb:
  lcd_command();
  _f_7 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x5DA6: sysex_dump_engine */
/* ====================================================================== */

/* System Exclusive dump engine (598 bytes).
   Manages complete MIDI SysEx data dump for backup/restore.
   Handles chunked transfer with handshaking. */

void sysex_dump_engine(byte *param_1,byte param_2,byte param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  undefined1 uVar5;
  char cVar6;
  undefined1 uVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  byte bVar14;
  short sVar12;
  byte *pbVar13;
  
  uEXTMEM00e0 = sysex_dump_helper();
  cEXTMEM00e1 = param_2 / 10 + 0x30;
  cEXTMEM00e2 = param_2 % 10 + 0x30;
  uEXTMEM00e3 = 0x2f;
  cEXTMEM00e4 = param_3 / 10 + 0x30;
  cEXTMEM00e5 = param_3 % 10 + 0x30;
  uEXTMEM00e6 = 0x3a;
  uEXTMEM00e7 = 0x20;
  bVar8 = *param_1;
  bVar4 = param_1[1];
  bVar10 = param_1[2];
  bVar11 = param_1[3];
  param_1 = param_1 + 4;
  bVar14 = (byte)param_1;
  if ((bVar8 & 0x80) == 0) {
    if ((char)bVar4 < '\0') {
      active_track_mask = 6;
      lcd_write_byte_hex(0x2d8b);
      goto LAB_CODE_5feb;
    }
    active_track_mask = 5;
    sVar12 = CONCAT11((char)((ushort)current_track_idx * 4 >> 8) + '`',0x3d);
    cVar6 = '\x04';
    bVar14 = 0xe8;
    do {
      bVar3 = bVar14;
      *(undefined1 *)(ushort)bVar3 =
           *(undefined1 *)(sVar12 + ((ushort)current_track_idx * 4 & 0xff));
      sVar12 = sVar12 + 1;
      cVar6 = cVar6 + -1;
      bVar14 = bVar3 + 1;
    } while (cVar6 != '\0');
    *(undefined1 *)(ushort)(bVar3 + 1) = 0x20;
    sysex_dump_checksum(bVar8,bVar3 + 2);
    if (bVar11 == 0) {
      bVar10 = bVar10 + 1;
    }
    bVar11 = memory_block_copy(0x60,BANK0_R4,BANK0_R0);
    cVar6 = '\0';
    bVar8 = BANK0_R0;
    if (bVar10 != 0) {
      cVar6 = '\x02';
      bVar8 = BANK0_R0 + 0x38;
    }
    *(byte *)(ushort)BANK0_R3 = bVar8 / 100 + 0x30 + cVar6;
    *(byte *)(ushort)(BANK0_R3 + 1) = (bVar8 % 100) / 10 + 0x30;
    *(byte *)(ushort)(BANK0_R3 + 2) = (bVar8 % 100) % 10 + 0x30;
    *(undefined1 *)(ushort)(BANK0_R3 + 3) = 0x2f;
    *(byte *)(ushort)(BANK0_R3 + 4) = bVar11 / 10 + 0x30;
    *(byte *)(ushort)(BANK0_R3 + 5) = bVar11 % 10 + 0x30;
    *(undefined1 *)(ushort)(BANK0_R3 + 6) = 0x20;
    bVar3 = BANK0_R3 + 7;
  }
  else {
    bVar8 = bVar8 & 0x7f;
    active_track_mask = current_track_idx + 0x87;
    if (current_track_idx < 0x79) {
      active_track_mask = 0;
    }
    bVar3 = (active_track_mask << 1 | active_track_mask >> 7) << 1;
    bVar9 = (bVar3 | (active_track_mask << 1) >> 7) << 1 | bVar3 >> 7;
    cVar6 = '\b';
    bVar2 = 0xe8;
    do {
      bVar3 = bVar2;
      *(undefined1 *)(ushort)bVar3 = *(undefined1 *)((ushort)bVar9 + 0x6015);
      bVar2 = bVar3 + 1;
      bVar9 = bVar9 + 1;
      cVar6 = cVar6 + -1;
    } while (cVar6 != '\0');
    if (current_track_idx == 0x7a) {
LAB_CODE_5e8c:
      *(undefined1 *)(ushort)bVar2 = 0x20;
      bVar3 = bVar3 + 2;
      sysex_dump_checksum(bVar8);
      *(undefined1 *)(ushort)bVar3 = 0x20;
      *(undefined1 *)(ushort)(bVar3 + 1) = 0x20;
      *(undefined1 *)(ushort)(bVar3 + 2) = 0x20;
      bVar3 = bVar3 + 3;
    }
    else if (current_track_idx < 0x7a) {
      sysex_dump_checksum();
      *(undefined1 *)(ushort)bVar2 = 0x3a;
      bVar3 = bVar2 + 1;
      sysex_dump_checksum(bVar8);
    }
    else {
      if (current_track_idx != 0x7c) {
        if (current_track_idx < 0x7c) goto LAB_CODE_5e8c;
        cVar6 = (char)((ushort)param_1 >> 8) + (((bVar14 < 7) << 7) >> 7);
        if (*(char *)CONCAT11(cVar6,bVar14 - 7) < '\0') {
LAB_CODE_5f6e:
          *(undefined1 *)(ushort)bVar2 = 0x20;
        }
        else {
          pbVar13 = (byte *)CONCAT11(cVar6 + (((bVar14 - 7 < 5) << 7) >> 7),bVar14 - 0xc);
          if ((*pbVar13 & 0x80) == 0) {
            bVar10 = pbVar13[2];
          }
          else {
            bVar10 = *pbVar13 & 0x7f;
          }
          if (((bVar10 != 0x7d) || ((char)pbVar13[4] < '\0')) || ((char)pbVar13[6] < '\0'))
          goto LAB_CODE_5f6e;
          *(undefined1 *)(ushort)bVar2 = 0x7f;
        }
        *(undefined1 *)(ushort)(bVar3 + 2) = 0x20;
        bVar3 = bVar3 + 3;
        sysex_dump_checksum(bVar8);
        *(undefined1 *)(ushort)bVar3 = 0x20;
        bVar3 = bVar3 + 1;
        if (-1 < (char)bVar4) {
          sysex_dump_checksum();
          *(undefined1 *)(ushort)bVar3 = 0x20;
          bVar3 = bVar3 + 1;
          if ((-1 < (char)bVar11) && (sysex_dump_checksum(), *param_1 == 0x7d)) {
            *(undefined1 *)(ushort)bVar3 = 0x20;
            *(undefined1 *)(ushort)(bVar3 + 1) = 0x7e;
            bVar3 = bVar3 + 2;
          }
        }
        do {
          *(undefined1 *)(ushort)bVar3 = 0x20;
          bVar3 = bVar3 + 1;
        } while (bVar3 != 0);
        goto LAB_CODE_5feb;
      }
      bVar8 = bVar11 >> 1;
      bVar10 = bVar10 & 0x7f | bVar11 << 7;
      uVar5 = 0x20;
      if ((bVar8 & 0x20) == 0) {
        bVar1 = bVar10 != 0;
        bVar10 = -bVar10;
        bVar8 = 0x20 - (bVar8 - ((bVar1 << 7) >> 7));
        uVar5 = 0x2d;
      }
      else {
        bVar8 = bVar8 & 0xdf;
      }
      *(undefined1 *)(ushort)bVar2 = uVar5;
      bVar11 = bVar8 >> 2 & 0xf;
      bVar8 = (bVar8 & 3) - ((CARRY1(bVar11 * '\x18',bVar10) << 7) >> 7);
      if ((bVar8 >> 2 & 1) == 0) {
        if ((bVar8 == 3) && (0xe7 < bVar11 * '\x18' + bVar10)) {
          bVar8 = 0;
          bVar11 = bVar11 + 1;
        }
      }
      else {
        bVar8 = 0;
        bVar11 = bVar11 + 1;
      }
      *(byte *)(ushort)(bVar3 + 2) = bVar11 + 0x30;
      cVar6 = BANK0_R1;
      bVar8 = memory_block_copy(100,BANK0_R7,BANK0_R0,bVar8);
      *(char *)(ushort)BANK0_R3 = cVar6 + '0';
      *(byte *)(ushort)(BANK0_R3 + 1) = bVar8 / 10 + 0x30;
      *(byte *)(ushort)(BANK0_R3 + 2) = bVar8 % 10 + 0x30;
      *(undefined1 *)(ushort)(BANK0_R3 + 3) = 0x20;
      *(undefined1 *)(ushort)(BANK0_R3 + 4) = 0x20;
      bVar3 = BANK0_R3 + 5;
    }
  }
  *(undefined1 *)(ushort)bVar3 = 0x20;
  *(undefined1 *)(ushort)(bVar3 + 1) = 0x43;
  *(undefined1 *)(ushort)(bVar3 + 2) = 0x48;
  *(undefined1 *)(ushort)(bVar3 + 3) = 0x41;
  *(undefined1 *)(ushort)(bVar3 + 4) = 0x4e;
  uVar7 = 0x20;
  uVar5 = 0x20;
  if (*(char *)CONCAT11(4,solo_track_num + -0x25) != '\0') {
    uVar7 = 0x28;
    uVar5 = 0x29;
  }
  *(undefined1 *)(ushort)(bVar3 + 5) = uVar7;
  *(byte *)(ushort)(bVar3 + 6) = (bVar4 + 1) / 10 + 0x30;
  *(byte *)(ushort)(bVar3 + 7) = (bVar4 + 1) % 10 + 0x30;
  *(undefined1 *)(ushort)(bVar3 + 8) = uVar5;
LAB_CODE_5feb:
  lcd_command();
  _f_7 = 0;
  return;
}



/* ====================================================================== */
/* Function at 0x5FFC: sysex_dump_checksum */
/* ====================================================================== */

/* Compute checksum for SysEx data dump block. */

void sysex_dump_checksum(byte param_1,byte param_2)

{
  *(byte *)(ushort)param_2 = param_1 / 100 + 0x30;
  *(byte *)(ushort)(param_2 + 1) = (param_1 % 100) / 10 + 0x30;
  *(byte *)(ushort)(param_2 + 2) = (param_1 % 100) % 10 + 0x30;
  return;
}



/* ====================================================================== */
/* Function at 0x623D: handle_auto_continue_record */
/* ====================================================================== */

/* Handle automatic continue into next recording pass.
   Manages loop recording / overdub continuation. */

void handle_auto_continue_record(void)

{
  char cVar1;
  byte bVar2;
  byte bVar3;
  
  BANK1_R7 = 0;
  BANK1_R6 = 0;
  BANK1_R5 = 0;
  BANK1_R2 = 0;
  IO_STATUS_LATCH = IO_STATUS_LATCH & 0xf7;
  cVar1 = solo_track_num + '\x01';
  bVar3 = 0;
  bVar2 = 0xff;
  do {
    IO_LED_DATA = bVar2 << 1 | bVar3 >> 7;
    bVar3 = bVar2 & 0x80;
    cVar1 = cVar1 + -1;
    bVar2 = IO_LED_DATA;
  } while (cVar1 != '\0');
  display_ptr_lo = 0x76;
  display_ptr_hi = 0x62;
  _f_7 = 0;
  uEXTMEMff1b = 0x6c;
  IO_IDLE_COUNTER = 0x94;
  process_sysex_data_dump();
  return;
}



/* ====================================================================== */
/* Function at 0x6C94: process_sysex_data_dump */
/* ====================================================================== */

/* Process MIDI System Exclusive data dump.
   Handles bulk data transfer for save/load operations. */

void process_sysex_data_dump(byte param_1,byte param_2)

{
  undefined1 uVar1;
  undefined1 uVar2;
  byte bVar3;
  byte *pbVar4;
  
  uVar2 = BANK0_R1;
  uVar1 = BANK0_R0;
  saved_P2_page = 5;
  P2 = 5;
  pbVar4 = (byte *)CONCAT11(*(undefined1 *)(solo_track_num * '\x02' + '^'),
                            *(undefined1 *)(solo_track_num * '\x02' + ']'));
  current_track_idx = *pbVar4 & 0x7f;
  pbVar4 = pbVar4 + 2;
  if ((BANK1_R2 != '\0') && (BANK1_R2 != '\x01')) {
    bVar3 = (BANK1_R2 - 2U) * '\x10';
    bVar3 = (BANK1_R2 - 2U >> 4 | bVar3) << 1 | bVar3 >> 7;
    lcd_write_byte_hex(CONCAT11('+' - (((0x74 < bVar3) << 7) >> 7),bVar3 + 0x8b));
    BANK0_R0 = uVar1;
    BANK0_R1 = uVar2;
    uEXTMEM05f3 = sysex_dump_helper();
    cEXTMEM05f4 = param_1 / 10 + 0x30;
    cEXTMEM05f5 = param_1 % 10 + 0x30;
    uEXTMEM05f6 = 0x2f;
    cEXTMEM05f7 = param_2 / 10 + 0x30;
    cEXTMEM05f8 = param_2 % 10 + 0x30;
    lcd_command();
    return;
  }
  if (BANK1_R6 != 0 || BANK1_R7 != '\0') {
    pbVar4 = (byte *)CONCAT11(BANK1_R7 +
                              ((char)((ushort)pbVar4 >> 8) -
                              ((CARRY1(BANK1_R6,(byte)pbVar4) << 7) >> 7)),BANK1_R6 + (byte)pbVar4);
    current_track_idx = *pbVar4;
  }
  sysex_dump_engine(pbVar4 + 1);
  BANK1_R4 = active_track_mask;
  if (_d_7 != '\x01') {
    if (BANK1_R2 != '\0') {
      saved_P2_page = 5;
      P2 = 5;
      lcd_busy_wait(0x2d9b,0xf0,0x10);
      lcd_command();
      return;
    }
    while (bVar3 = (active_track_mask << 1 | active_track_mask >> 7) << 1,
          *(char *)((ushort)(((bVar3 | (active_track_mask << 1) >> 7) << 1 | bVar3 >> 7) + BANK1_R5)
                   + 0x6daa) == '\0') {
      BANK1_R5 = '\0';
    }
    lcd_write_char();
  }
  return;
}



/* ====================================================================== */
/* Function at 0x6D62: sysex_dump_helper */
/* ====================================================================== */

/* Helper for SysEx dump byte formatting. */

char sysex_dump_helper(byte param_1,char param_2)

{
  bool bVar1;
  char cVar2;
  byte bVar3;
  
  memory_block_copy(0x60);
  bVar3 = param_1 + 1;
  param_2 = param_2 - (((0xfe < param_1) << 7) >> 7);
  cVar2 = param_2;
  if (param_2 != '\0') {
    if (param_2 == '\x02') {
      cVar2 = '\x05';
      bVar3 = param_1 + 0xd;
    }
    else {
      cVar2 = param_2 + '\x01';
      bVar1 = 199 < bVar3;
      bVar3 = param_1 + 0x39;
      if (bVar1) {
        cVar2 = param_2 + '\x03';
        bVar3 = param_1 + 0x71;
      }
    }
  }
  return bVar3 / 100 + 0x30 + cVar2;
}



/* ====================================================================== */
/* Function at 0x6D90: init_metronome_click */
/* ====================================================================== */

/* Initialize metronome/click output.
   Sets up click timing based on time signature. */

void init_metronome_click(byte param_1,byte param_2)

{
  sequence_edit_operations();
  uEXTMEM02bb = 0x80;
  bEXTMEM02bc = param_1 & 0x7f;
  bEXTMEM02bd = (param_2 & 0x3f) << 1 | param_1 >> 7;
  process_midi_realtime_msgs();
  return;
}



/* ====================================================================== */
/* Function at 0x7340: handle_midi_channel_filter */
/* ====================================================================== */

/* Handle MIDI channel/filter settings.
   Configures per-track MIDI channel assignment and filtering. */

void handle_midi_channel_filter(void)

{
  solo_track_num = 0;
  midi_filter_impl();
  DAT_INTMEM_49 = 0;
  _e_1 = 0;
  uEXTMEMff1b = 0x73;
  IO_IDLE_COUNTER = 0xe1;
  display_ptr_lo = 0x5f;
  display_ptr_hi = 0x73;
  return;
}



/* ====================================================================== */
/* Function at 0x73E1: midi_filter_impl */
/* ====================================================================== */

/* MIDI channel filter implementation.
   Sets per-track MIDI channel routing. */

void midi_filter_impl(void)

{
  char cVar1;
  byte bVar2;
  undefined1 uVar3;
  undefined1 *puVar4;
  
  bVar2 = (solo_track_num >> 4 | solo_track_num << 4) << 1 | (solo_track_num << 4) >> 7;
  uVar3 = 0x29;
  if (0xf4 < bVar2) {
    uVar3 = 0x2a;
  }
  lcd_write_byte_hex(CONCAT11(uVar3,bVar2 + 0xb));
  if ((solo_track_num != 3) && (solo_track_num != 4)) {
    bVar2 = 0xe0;
    saved_P2_page = 5;
    P2 = 5;
    lcd_write_char(0x80);
    lcd_write_digit();
    lcd_write_char(0xc0);
    cVar1 = '\x10';
    puVar4 = (undefined1 *)0xff09;
    do {
      *puVar4 = *(undefined1 *)(ushort)bVar2;
      lcd_set_cursor();
      bVar2 = bVar2 + 1;
      cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
    return;
  }
  lcd_write_string_inline(0x1c,DAT_INTMEM_49);
  LCD_CMD_DATA = 0xcc;
  lcd_set_cursor();
  nop();
  nop();
  nop();
  nop();
  nop();
  return;
}



/* ====================================================================== */
/* Function at 0x76B2: TIMER1_isr */
/* ====================================================================== */

/* Timer 1 ISR: UART baud rate generator.
   Timer 1 in mode 2 (8-bit auto-reload) generates 31.25 kbaud
   MIDI baud rate. TH1=0xFF at 12MHz = 31.25kbaud.
   This ISR handles overflow events if any additional
   Timer1-based timing is needed. */

undefined1 TIMER1_isr(undefined1 param_1)

{
  byte bVar1;
  
  bVar1 = active_track_mask;
  active_track_mask = active_track_mask >> 1;
  P3 = (bVar1 & 1 | 0xfe) << 4 | 0xf;
  return param_1;
}



/* ====================================================================== */
/* Function at 0x7C2D: selftest_ram_rw */
/* ====================================================================== */

/* Self-test: RAM read/write test.
   Writes pattern to XDATA RAM via HC574 latch outputs,
   reads back and verifies. Tests both 61256 RAM chips. */

void selftest_ram_rw(byte *param_1,byte param_2,char param_3)

{
  do {
    *param_1 = param_2;
    selftest_delay_loop();
    param_2 = param_2 << 1 | 1;
    param_3 = param_3 + -1;
  } while (param_3 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x7C3C: selftest_delay_loop */
/* ====================================================================== */

/* Self-test: delay loop between test phases. */

void selftest_delay_loop(void)

{
  char cVar1;
  char cVar2;
  char cVar3;
  
  cVar1 = '\0';
  cVar2 = '\0';
  cVar3 = '\x04';
  do {
    do {
      cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
    cVar2 = cVar2 + -1;
  } while ((cVar2 != '\0') || (cVar3 = cVar3 + -1, cVar3 != '\0'));
  return;
}



/* ====================================================================== */
/* Function at 0x7C49: selftest_pass_msg */
/* ====================================================================== */

/* Self-test: display PASS message and continue. */

void selftest_pass_msg(void)

{
  byte bVar1;
  char cVar2;
  undefined1 *puVar3;
  
  selftest_fail_halt();
  bVar1 = 0xe0;
  saved_P2_page = 5;
  P2 = 5;
  lcd_write_char(0x80);
  lcd_write_digit();
  lcd_write_char(0xc0);
  cVar2 = '\x10';
  puVar3 = (undefined1 *)0xff09;
  do {
    *puVar3 = *(undefined1 *)(ushort)bVar1;
    lcd_set_cursor();
    bVar1 = bVar1 + 1;
    cVar2 = cVar2 + -1;
  } while (cVar2 != '\0');
  return;
}



/* ====================================================================== */
/* Function at 0x7C4F: selftest_show_message */
/* ====================================================================== */

/* Self-test: display a test status message on LCD.
   Takes CODE memory address of message string. */

void selftest_show_message(void)

{
  char cVar1;
  char cVar2;
  char cVar3;
  
  selftest_fail_halt();
  lcd_command();
  selftest_delay_loop();
  selftest_delay_loop();
  cVar1 = '\0';
  cVar2 = '\0';
  cVar3 = '\x04';
  do {
    do {
      cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
    cVar2 = cVar2 + -1;
  } while ((cVar2 != '\0') || (cVar3 = cVar3 + -1, cVar3 != '\0'));
  return;
}



/* ====================================================================== */
/* Function at 0x7C5D: selftest_fail_halt */
/* ====================================================================== */

/* Self-test: display FAIL message and halt.
   Enters infinite loop on test failure. */

void selftest_fail_halt(void)

{
  P2 = 5;
  lcd_busy_wait(0xf0,0x10);
  return;
}

